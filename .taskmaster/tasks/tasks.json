{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Next.js 15 프로젝트 초기 설정",
        "description": "Next.js 15 App Router를 사용한 프로젝트 구조 설정 및 기본 의존성 설치",
        "details": "1. Node.js v18+ 환경 확인\n2. `npx create-next-app@latest` 명령어로 프로젝트 생성\n3. TypeScript, Tailwind CSS, ESLint 옵션 선택\n4. App Router 구조 선택\n5. 주요 의존성 설치:\n   - `@supabase/ssr`\n   - `openai`\n   - `class-variance-authority`\n   - `@radix-ui` 컴포넌트\n6. 환경 변수 파일 (.env.local) 설정:\n   - NEXT_PUBLIC_SUPABASE_URL\n   - NEXT_PUBLIC_SUPABASE_ANON_KEY\n   - SUPABASE_SERVICE_ROLE_KEY\n   - OPENAI_API_KEY\n7. 기본 폴더 구조 설정:\n   - app/ (라우팅)\n   - components/ (UI 컴포넌트)\n   - lib/ (유틸리티 함수)\n   - types/ (TypeScript 타입 정의)\n   - styles/ (글로벌 스타일)",
        "testStrategy": "1. 프로젝트가 오류 없이 빌드되는지 확인\n2. 개발 서버 실행 후 기본 페이지 로드 확인\n3. 환경 변수가 올바르게 로드되는지 확인\n4. TypeScript 타입 체크 통과 확인",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Supabase 연동 및 데이터베이스 스키마 설정",
        "description": "Supabase 프로젝트 설정 및 필요한 테이블 스키마 구성",
        "details": "1. Supabase 프로젝트 생성\n2. 다음 테이블 스키마 설정:\n   - users: id(PK), email, created_at, updated_at\n   - sessions: id(PK), user_id(FK), title, created_at, updated_at, status\n   - messages: id(PK), session_id(FK), role(user/assistant), content, character_type, created_at\n   - payments: id(PK), user_id(FK), amount, status, created_at\n3. Row Level Security (RLS) 정책 설정:\n   - users: 자신의 데이터만 읽기/쓰기 가능\n   - sessions: 소유자만 읽기/쓰기 가능\n   - messages: 세션 소유자만 읽기/쓰기 가능\n4. 인덱스 설정:\n   - sessions: user_id, created_at\n   - messages: session_id, created_at\n5. Supabase 클라이언트 설정 (lib/supabase.ts):\n   ```typescript\n   import { createClient } from '@supabase/ssr'\n   \n   export const createSupabaseClient = () => {\n     return createClient(\n       process.env.NEXT_PUBLIC_SUPABASE_URL!,\n       process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n     )\n   }\n   ```",
        "testStrategy": "1. 테이블 생성 및 관계 설정 검증\n2. RLS 정책 테스트 (권한 없는 사용자의 접근 차단 확인)\n3. 테스트 데이터 삽입 및 조회 테스트\n4. Supabase 클라이언트 연결 테스트",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "사용자 인증 시스템 구현",
        "description": "Supabase Auth를 활용한 이메일 기반 회원가입/로그인 시스템 구현",
        "details": "1. 인증 관련 컴포넌트 생성:\n   - components/auth/LoginForm.tsx\n   - components/auth/SignupForm.tsx\n   - components/auth/AuthLayout.tsx\n2. 인증 페이지 생성:\n   - app/login/page.tsx\n   - app/signup/page.tsx\n3. Supabase Auth 통합:\n   ```typescript\n   // lib/auth.ts\n   import { createSupabaseClient } from './supabase'\n   \n   export async function signUp(email: string, password: string) {\n     const supabase = createSupabaseClient()\n     return await supabase.auth.signUp({ email, password })\n   }\n   \n   export async function signIn(email: string, password: string) {\n     const supabase = createSupabaseClient()\n     return await supabase.auth.signInWithPassword({ email, password })\n   }\n   \n   export async function signOut() {\n     const supabase = createSupabaseClient()\n     return await supabase.auth.signOut()\n   }\n   ```\n4. 인증 상태 관리 미들웨어 구현 (middleware.ts)\n5. 보호된 라우트 설정 (로그인 필요한 페이지)",
        "testStrategy": "1. 회원가입 플로우 테스트 (이메일 검증 포함)\n2. 로그인/로그아웃 기능 테스트\n3. 보호된 라우트 접근 제한 테스트\n4. 인증 오류 처리 및 사용자 피드백 테스트\n5. 세션 지속성 테스트 (페이지 새로고침 후)",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "대시보드 페이지 구현",
        "description": "사용자의 진행 중인 상담과 완료된 상담 목록을 표시하는 대시보드 페이지 구현",
        "details": "1. 대시보드 페이지 생성 (app/page.tsx)\n2. 세션 목록 컴포넌트 구현:\n   ```typescript\n   // components/dashboard/SessionList.tsx\n   import { Session } from '@/types'\n   \n   interface SessionListProps {\n     sessions: Session[]\n     type: 'active' | 'completed'\n     onSessionSelect: (sessionId: string) => void\n   }\n   \n   export function SessionList({ sessions, type, onSessionSelect }: SessionListProps) {\n     return (\n       <div className=\"space-y-4\">\n         <h2 className=\"text-xl font-semibold\">\n           {type === 'active' ? '진행 중인 상담' : '완료된 상담'}\n         </h2>\n         <div className=\"space-y-2\">\n           {sessions.map((session) => (\n             <div \n               key={session.id}\n               onClick={() => onSessionSelect(session.id)}\n               className=\"p-4 border rounded-lg hover:bg-gray-50 cursor-pointer\"\n             >\n               <h3 className=\"font-medium\">{session.title || '제목 없음'}</h3>\n               <p className=\"text-sm text-gray-500\">\n                 {new Date(session.created_at).toLocaleDateString()}\n               </p>\n               {session.last_message && (\n                 <p className=\"mt-2 text-sm truncate\">{session.last_message}</p>\n               )}\n             </div>\n           ))}\n         </div>\n       </div>\n     )\n   }\n   ```\n3. \"새 상담 시작\" 버튼 구현\n4. 세션 데이터 가져오는 API 구현:\n   ```typescript\n   // lib/sessions.ts\n   import { createSupabaseClient } from './supabase'\n   \n   export async function getUserSessions(userId: string) {\n     const supabase = createSupabaseClient()\n     \n     const { data: sessions, error } = await supabase\n       .from('sessions')\n       .select('*, messages(content, created_at)')\n       .eq('user_id', userId)\n       .order('created_at', { ascending: false })\n     \n     if (error) throw error\n     \n     return sessions.map(session => ({\n       ...session,\n       last_message: session.messages?.[0]?.content || null\n     }))\n   }\n   ```\n5. 세션 선택 시 해당 상담 페이지로 이동하는 기능",
        "testStrategy": "1. 세션 목록 데이터 로딩 테스트\n2. 세션 필터링 (진행 중/완료) 기능 테스트\n3. 세션 선택 시 올바른 페이지로 이동하는지 테스트\n4. \"새 상담 시작\" 버튼 기능 테스트\n5. 로딩 상태 및 오류 처리 테스트\n6. 반응형 디자인 테스트 (모바일/데스크톱)",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "in-progress",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "상담 세션 관리 시스템 구현",
        "description": "상담 세션 생성, 저장, 이어서 진행하는 기능 구현",
        "details": "1. 세션 관리 API 구현:\n   ```typescript\n   // lib/sessions.ts\n   export async function createSession(userId: string) {\n     const supabase = createSupabaseClient()\n     \n     const { data, error } = await supabase\n       .from('sessions')\n       .insert({\n         user_id: userId,\n         status: 'active',\n         title: `상담 ${new Date().toLocaleDateString()}`\n       })\n       .select()\n     \n     if (error) throw error\n     return data[0]\n   }\n   \n   export async function getSessionById(sessionId: string) {\n     const supabase = createSupabaseClient()\n     \n     const { data, error } = await supabase\n       .from('sessions')\n       .select('*')\n       .eq('id', sessionId)\n       .single()\n     \n     if (error) throw error\n     return data\n   }\n   \n   export async function updateSessionStatus(sessionId: string, status: 'active' | 'completed') {\n     const supabase = createSupabaseClient()\n     \n     const { error } = await supabase\n       .from('sessions')\n       .update({ status })\n       .eq('id', sessionId)\n     \n     if (error) throw error\n     return true\n   }\n   ```\n2. 세션 메시지 관리 API 구현:\n   ```typescript\n   // lib/messages.ts\n   export async function getSessionMessages(sessionId: string) {\n     const supabase = createSupabaseClient()\n     \n     const { data, error } = await supabase\n       .from('messages')\n       .select('*')\n       .eq('session_id', sessionId)\n       .order('created_at', { ascending: true })\n     \n     if (error) throw error\n     return data\n   }\n   \n   export async function addMessage(sessionId: string, role: 'user' | 'assistant', content: string, character_type?: string) {\n     const supabase = createSupabaseClient()\n     \n     const { data, error } = await supabase\n       .from('messages')\n       .insert({\n         session_id: sessionId,\n         role,\n         content,\n         character_type\n       })\n       .select()\n     \n     if (error) throw error\n     return data[0]\n   }\n   ```\n3. 세션 상태 관리 (진행 중/완료) 기능 구현",
        "testStrategy": "1. 세션 생성 기능 테스트\n2. 세션 상태 업데이트 테스트\n3. 세션 메시지 저장 및 조회 테스트\n4. 세션 간 전환 시 데이터 일관성 테스트\n5. 동시성 이슈 테스트 (여러 탭에서 동일 세션 접근)",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "온보딩/튜토리얼 시스템 구현",
        "description": "새 상담 시작 시 제공되는 풀스크린 게임적 UI/UX 튜토리얼 시스템 구현",
        "details": "1. 온보딩 컴포넌트 구현:\n   ```typescript\n   // components/onboarding/OnboardingScreen.tsx\n   import { useState } from 'react'\n   \n   const ONBOARDING_STEPS = [\n     {\n       title: '환영합니다!',\n       message: '메인 캐릭터가 상담을 진행합니다.',\n       character: 'main'\n     },\n     {\n       title: '편안한 환경을 만드세요',\n       message: '가장 마음이 차분해지는 곳으로 가서 마음에 드는 노래를 틀어보세요.',\n       character: 'main'\n     },\n     {\n       title: '당신의 Why를 찾아봐요',\n       message: '내 인생의 가장 중요한 한마디를 찾아가는 것입니다.',\n       character: 'main'\n     },\n     {\n       title: '천천히 진행하세요',\n       message: '한번에 정확하게 모두 찾을 수 있을 거라 생각하지 마세요.',\n       character: 'main'\n     },\n     {\n       title: '꾸준히 해보세요',\n       message: '적어도 5번은 해보세요.',\n       character: 'main'\n     },\n     {\n       title: '자기 자신에게 집중하세요',\n       message: '그 과정에서 나도 모르게 나에게 집중하고 있다는 것을 알게 될 것입니다.',\n       character: 'main'\n     }\n   ]\n   \n   export function OnboardingScreen({ onComplete }: { onComplete: () => void }) {\n     const [currentStep, setCurrentStep] = useState(0)\n     \n     const nextStep = () => {\n       if (currentStep < ONBOARDING_STEPS.length - 1) {\n         setCurrentStep(currentStep + 1)\n       } else {\n         onComplete()\n       }\n     }\n     \n     const step = ONBOARDING_STEPS[currentStep]\n     \n     return (\n       <div className=\"fixed inset-0 bg-gradient-to-b from-indigo-500 to-purple-600 flex items-center justify-center z-50\">\n         <div className=\"max-w-md w-full p-6 bg-white rounded-lg shadow-xl\">\n           <div className=\"mb-6 flex justify-center\">\n             {/* Character image based on step.character */}\n             <div className=\"w-24 h-24 rounded-full bg-indigo-100 flex items-center justify-center\">\n               {step.character === 'main' && '🌟'}\n             </div>\n           </div>\n           \n           <h2 className=\"text-2xl font-bold text-center mb-4\">{step.title}</h2>\n           <p className=\"text-center text-gray-700 mb-8\">{step.message}</p>\n           \n           <div className=\"flex justify-center\">\n             <button \n               onClick={nextStep}\n               className=\"px-6 py-2 bg-indigo-600 text-white rounded-full hover:bg-indigo-700 transition-colors\"\n             >\n               {currentStep < ONBOARDING_STEPS.length - 1 ? '다음' : '시작하기'}\n             </button>\n           </div>\n           \n           <div className=\"mt-6 flex justify-center space-x-2\">\n             {ONBOARDING_STEPS.map((_, index) => (\n               <div \n                 key={index}\n                 className={`w-2 h-2 rounded-full ${index === currentStep ? 'bg-indigo-600' : 'bg-gray-300'}`}\n               />\n             ))}\n           </div>\n         </div>\n       </div>\n     )\n   }\n   ```\n2. 온보딩 상태 관리 (완료 여부 저장)\n3. 게임적 UI/UX 요소 추가 (애니메이션, 사운드 효과 등)\n4. 온보딩 완료 후 상담 시작 연결",
        "testStrategy": "1. 온보딩 단계별 진행 테스트\n2. 온보딩 완료 상태 저장 및 확인 테스트\n3. 모바일/데스크톱 환경에서의 UI 테스트\n4. 애니메이션 및 전환 효과 테스트\n5. 사용자 인터랙션 테스트 (버튼 클릭, 스와이프 등)",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "상담사 캐릭터 시스템 구현",
        "description": "메인 상담사와 3개의 특화된 상담사 캐릭터 시스템 구현",
        "details": "1. 캐릭터 타입 정의:\n   ```typescript\n   // types/characters.ts\n   export type CharacterType = 'main' | 'yellow' | 'bibi' | 'green'\n   \n   export interface Character {\n     type: CharacterType\n     emoji: string\n     name: string\n     description: string\n     color: string\n     gradientFrom: string\n     gradientTo: string\n     tone: string\n   }\n   ```\n2. 캐릭터 데이터 정의:\n   ```typescript\n   // lib/characters.ts\n   import { Character } from '@/types/characters'\n   \n   export const CHARACTERS: Record<CharacterType, Character> = {\n     main: {\n       type: 'main',\n       emoji: '🌟',\n       name: '메인 상담사',\n       description: '인트로, Why 생성, 전체 진행 관리',\n       color: '#6366f1', // indigo-500\n       gradientFrom: '#818cf8', // indigo-400\n       gradientTo: '#4f46e5', // indigo-600\n       tone: '친절하고 안내하는 톤'\n     },\n     yellow: {\n       type: 'yellow',\n       emoji: '🌞',\n       name: '옐로',\n       description: '뿌듯함, 보람 관련 질문',\n       color: '#facc15', // yellow-400\n       gradientFrom: '#fef08a', // yellow-200\n       gradientTo: '#eab308', // yellow-500\n       tone: '밝고 긍정적인 톤'\n     },\n     bibi: {\n       type: 'bibi',\n       emoji: '🦋',\n       name: '비비',\n       description: '감정, 좋은/힘든 순간 탐구',\n       color: '#3b82f6', // blue-500\n       gradientFrom: '#93c5fd', // blue-300\n       gradientTo: '#2563eb', // blue-600\n       tone: '차분하고 깊이 있는 톤'\n     },\n     green: {\n       type: 'green',\n       emoji: '🌿',\n       name: '그린',\n       description: '꿈과 비전 탐구',\n       color: '#22c55e', // green-500\n       gradientFrom: '#86efac', // green-300\n       gradientTo: '#16a34a', // green-600\n       tone: '자연스럽고 안정적인 톤'\n     }\n   }\n   ```\n3. 캐릭터별 메시지 버블 컴포넌트 구현:\n   ```typescript\n   // components/chat/CharacterMessage.tsx\n   import { Character } from '@/types/characters'\n   \n   interface CharacterMessageProps {\n     character: Character\n     message: string\n     isTyping?: boolean\n   }\n   \n   export function CharacterMessage({ character, message, isTyping = false }: CharacterMessageProps) {\n     return (\n       <div className=\"flex items-start mb-4\">\n         <div \n           className=\"w-10 h-10 rounded-full flex items-center justify-center mr-3\"\n           style={{ background: character.color }}\n         >\n           <span className=\"text-lg\">{character.emoji}</span>\n         </div>\n         \n         <div \n           className=\"max-w-[80%] p-3 rounded-lg\"\n           style={{ \n             background: `linear-gradient(to bottom right, ${character.gradientFrom}, ${character.gradientTo})`,\n             color: 'white'\n           }}\n         >\n           <div className=\"font-medium mb-1\">{character.name}</div>\n           <div>\n             {isTyping ? (\n               <span className=\"inline-flex items-center\">\n                 <span className=\"typing-dot\"></span>\n                 <span className=\"typing-dot\"></span>\n                 <span className=\"typing-dot\"></span>\n               </span>\n             ) : (\n               message\n             )}\n           </div>\n         </div>\n       </div>\n     )\n   }\n   ```\n4. 캐릭터 전환 로직 구현 (질문 단계에 따라)",
        "testStrategy": "1. 각 캐릭터 렌더링 테스트\n2. 캐릭터별 스타일 적용 확인\n3. 캐릭터 전환 로직 테스트\n4. 타이핑 효과 테스트\n5. 반응형 디자인 테스트",
        "priority": "medium",
        "dependencies": [
          1,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "OpenAI Assistant API 통합",
        "description": "OpenAI GPT-4o와 Assistant API를 활용한 상담 AI 통합",
        "details": "1. OpenAI 클라이언트 설정:\n   ```typescript\n   // lib/openai.ts\n   import OpenAI from 'openai'\n   \n   const openai = new OpenAI({\n     apiKey: process.env.OPENAI_API_KEY\n   })\n   \n   export default openai\n   ```\n2. Assistant 생성 및 관리:\n   ```typescript\n   // lib/assistant.ts\n   import openai from './openai'\n   \n   // 캐릭터별 Assistant 생성 함수\n   export async function createOrGetAssistant(characterType: CharacterType) {\n     // 실제 구현에서는 이미 생성된 Assistant ID를 환경변수나 DB에서 가져오는 것이 좋음\n     const assistantId = process.env[`OPENAI_${characterType.toUpperCase()}_ASSISTANT_ID`]\n     \n     if (assistantId) {\n       return assistantId\n     }\n     \n     // 새 Assistant 생성 (개발/테스트용)\n     const character = CHARACTERS[characterType]\n     \n     const assistant = await openai.beta.assistants.create({\n       name: `Why 상담사 - ${character.name}`,\n       instructions: `당신은 Why 상담사의 ${character.name} 캐릭터입니다. ${character.description}을 담당합니다. ${character.tone}으로 대화하세요.`,\n       model: \"gpt-4o\",\n     })\n     \n     return assistant.id\n   }\n   \n   // Thread 생성\n   export async function createThread() {\n     const thread = await openai.beta.threads.create()\n     return thread.id\n   }\n   \n   // 메시지 추가\n   export async function addMessageToThread(threadId: string, content: string, role: 'user' | 'assistant' = 'user') {\n     const message = await openai.beta.threads.messages.create(threadId, {\n       role,\n       content\n     })\n     return message\n   }\n   \n   // 응답 생성\n   export async function runAssistant(threadId: string, assistantId: string) {\n     const run = await openai.beta.threads.runs.create(threadId, {\n       assistant_id: assistantId\n     })\n     \n     // 완료될 때까지 대기\n     let runStatus = await openai.beta.threads.runs.retrieve(threadId, run.id)\n     \n     while (runStatus.status !== 'completed') {\n       await new Promise(resolve => setTimeout(resolve, 1000))\n       runStatus = await openai.beta.threads.runs.retrieve(threadId, run.id)\n       \n       if (runStatus.status === 'failed') {\n         throw new Error('Assistant run failed')\n       }\n     }\n     \n     // 응답 메시지 가져오기\n     const messages = await openai.beta.threads.messages.list(threadId)\n     return messages.data[0].content[0].text.value\n   }\n   ```\n3. API 라우트 구현:\n   ```typescript\n   // app/api/chat/route.ts\n   import { NextRequest, NextResponse } from 'next/server'\n   import { createOrGetAssistant, createThread, addMessageToThread, runAssistant } from '@/lib/assistant'\n   import { addMessage } from '@/lib/messages'\n   \n   export async function POST(req: NextRequest) {\n     try {\n       const { sessionId, message, characterType, threadId: existingThreadId } = await req.json()\n       \n       // Thread ID 가져오기 또는 생성\n       const threadId = existingThreadId || await createThread()\n       \n       // Assistant ID 가져오기\n       const assistantId = await createOrGetAssistant(characterType)\n       \n       // 사용자 메시지 추가\n       await addMessageToThread(threadId, message)\n       \n       // DB에 사용자 메시지 저장\n       await addMessage(sessionId, 'user', message)\n       \n       // 응답 생성\n       const response = await runAssistant(threadId, assistantId)\n       \n       // DB에 AI 응답 저장\n       await addMessage(sessionId, 'assistant', response, characterType)\n       \n       return NextResponse.json({ \n         threadId,\n         response,\n         characterType\n       })\n     } catch (error) {\n       console.error('Chat API error:', error)\n       return NextResponse.json({ error: 'Failed to process chat' }, { status: 500 })\n     }\n   }\n   ```",
        "testStrategy": "1. OpenAI API 연결 테스트\n2. Assistant 생성 및 관리 테스트\n3. Thread 생성 및 메시지 추가 테스트\n4. 응답 생성 및 처리 테스트\n5. 오류 처리 및 재시도 메커니즘 테스트\n6. 토큰 사용량 모니터링",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "구조화된 8단계 질문 시스템 구현",
        "description": "상담 과정의 8단계 질문 시스템 및 단계별 캐릭터 전환 구현",
        "details": "1. 상담 단계 정의:\n   ```typescript\n   // types/consultation.ts\n   export type ConsultationStage = \n     | 'intro'\n     | 'question1'\n     | 'question2'\n     | 'question3'\n     | 'question4'\n     | 'question5'\n     | 'question6'\n     | 'question7'\n     | 'question8'\n     | 'why_generation'\n     | 'completed'\n   \n   export interface StageConfig {\n     stage: ConsultationStage\n     character: CharacterType\n     title: string\n     description: string\n     initialPrompt: string\n   }\n   ```\n2. 단계별 설정 정의:\n   ```typescript\n   // lib/consultation-stages.ts\n   import { StageConfig } from '@/types/consultation'\n   \n   export const CONSULTATION_STAGES: StageConfig[] = [\n     {\n       stage: 'intro',\n       character: 'main',\n       title: '상담 시작',\n       description: '상담 안내 및 준비',\n       initialPrompt: '안녕하세요! Why 상담사입니다. 오늘 당신의 진정한 Why를 찾아보는 여정을 함께 하겠습니다. 준비되셨나요?'\n     },\n     {\n       stage: 'question1',\n       character: 'yellow',\n       title: '뿌듯함과 보람',\n       description: '뿌듯함을 느꼈던 순간들',\n       initialPrompt: '안녕하세요, 저는 옐로예요! 당신이 가장 뿌듯함과 보람을 느꼈던 순간들에 대해 이야기해 볼까요? 어떤 일을 했을 때 가장 큰 성취감을 느끼셨나요?'\n     },\n     // 나머지 단계 정의...\n     {\n       stage: 'why_generation',\n       character: 'main',\n       title: 'Why 문장 생성',\n       description: '개인화된 Why 문장 도출',\n       initialPrompt: '지금까지의 대화를 바탕으로 당신의 Why 문장을 만들어 보겠습니다. \"[방법/스타일]함으로써 [궁극적 감정 상태][세상/사람들에게][~한다]\" 형태로 정리해 드릴게요.'\n     }\n   ]\n   ```\n3. 상담 진행 관리 컴포넌트:\n   ```typescript\n   // components/consultation/ConsultationManager.tsx\n   import { useState, useEffect } from 'react'\n   import { ConsultationStage } from '@/types/consultation'\n   import { CONSULTATION_STAGES } from '@/lib/consultation-stages'\n   \n   export function ConsultationManager({ sessionId }: { sessionId: string }) {\n     const [currentStage, setCurrentStage] = useState<ConsultationStage>('intro')\n     const [threadId, setThreadId] = useState<string | null>(null)\n     \n     const stageConfig = CONSULTATION_STAGES.find(s => s.stage === currentStage)!\n     \n     // 단계 진행 함수\n     const advanceToNextStage = () => {\n       const currentIndex = CONSULTATION_STAGES.findIndex(s => s.stage === currentStage)\n       if (currentIndex < CONSULTATION_STAGES.length - 1) {\n         setCurrentStage(CONSULTATION_STAGES[currentIndex + 1].stage)\n       }\n     }\n     \n     // 나머지 구현...\n   }\n   ```\n4. 단계별 프롬프트 및 지시사항 관리",
        "testStrategy": "1. 각 상담 단계 전환 테스트\n2. 단계별 캐릭터 전환 테스트\n3. 단계별 초기 프롬프트 전송 테스트\n4. 상담 진행 상태 저장 및 복원 테스트\n5. 단계 건너뛰기 및 이전 단계로 돌아가기 테스트",
        "priority": "high",
        "dependencies": [
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "실시간 대화 인터페이스 구현",
        "description": "타이핑 효과와 캐릭터별 테마가 적용된 실시간 대화 인터페이스 구현",
        "details": "1. 채팅 인터페이스 컴포넌트:\n   ```typescript\n   // components/chat/ChatInterface.tsx\n   import { useState, useRef, useEffect } from 'react'\n   import { CharacterMessage } from './CharacterMessage'\n   import { UserMessage } from './UserMessage'\n   import { MessageInput } from './MessageInput'\n   import { Character } from '@/types/characters'\n   import { CHARACTERS } from '@/lib/characters'\n   \n   interface Message {\n     id: string\n     content: string\n     role: 'user' | 'assistant'\n     characterType?: CharacterType\n   }\n   \n   interface ChatInterfaceProps {\n     sessionId: string\n     currentCharacter: Character\n     onSendMessage: (message: string) => Promise<void>\n     messages: Message[]\n     isTyping: boolean\n   }\n   \n   export function ChatInterface({ \n     sessionId, \n     currentCharacter, \n     onSendMessage, \n     messages, \n     isTyping \n   }: ChatInterfaceProps) {\n     const messagesEndRef = useRef<HTMLDivElement>(null)\n     \n     // 스크롤 자동 이동\n     useEffect(() => {\n       messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })\n     }, [messages, isTyping])\n     \n     return (\n       <div className=\"flex flex-col h-full\">\n         <div \n           className=\"flex-1 overflow-y-auto p-4\"\n           style={{\n             background: `linear-gradient(to bottom, ${currentCharacter.gradientFrom}20, ${currentCharacter.gradientTo}10)`\n           }}\n         >\n           {messages.map(message => (\n             <div key={message.id}>\n               {message.role === 'user' ? (\n                 <UserMessage message={message.content} />\n               ) : (\n                 <CharacterMessage \n                   character={CHARACTERS[message.characterType || 'main']} \n                   message={message.content} \n                 />\n               )}\n             </div>\n           ))}\n           \n           {isTyping && (\n             <CharacterMessage \n               character={currentCharacter} \n               message=\"\" \n               isTyping={true} \n             />\n           )}\n           \n           <div ref={messagesEndRef} />\n         </div>\n         \n         <MessageInput \n           onSendMessage={onSendMessage} \n           disabled={isTyping} \n           characterColor={currentCharacter.color}\n         />\n       </div>\n     )\n   }\n   ```\n2. 타이핑 효과 구현:\n   ```typescript\n   // components/chat/TypingEffect.tsx\n   import { useState, useEffect } from 'react'\n   \n   export function TypingEffect({ text, speed = 30 }: { text: string, speed?: number }) {\n     const [displayedText, setDisplayedText] = useState('')\n     const [currentIndex, setCurrentIndex] = useState(0)\n     \n     useEffect(() => {\n       if (currentIndex < text.length) {\n         const timeout = setTimeout(() => {\n           setDisplayedText(prev => prev + text[currentIndex])\n           setCurrentIndex(prev => prev + 1)\n         }, speed)\n         \n         return () => clearTimeout(timeout)\n       }\n     }, [currentIndex, text, speed])\n     \n     useEffect(() => {\n       setDisplayedText('')\n       setCurrentIndex(0)\n     }, [text])\n     \n     return <span>{displayedText}</span>\n   }\n   ```\n3. 메시지 입력 컴포넌트:\n   ```typescript\n   // components/chat/MessageInput.tsx\n   import { useState } from 'react'\n   \n   interface MessageInputProps {\n     onSendMessage: (message: string) => Promise<void>\n     disabled: boolean\n     characterColor: string\n   }\n   \n   export function MessageInput({ onSendMessage, disabled, characterColor }: MessageInputProps) {\n     const [message, setMessage] = useState('')\n     \n     const handleSubmit = async (e: React.FormEvent) => {\n       e.preventDefault()\n       if (message.trim() && !disabled) {\n         setMessage('')\n         await onSendMessage(message)\n       }\n     }\n     \n     return (\n       <form onSubmit={handleSubmit} className=\"p-4 border-t bg-white\">\n         <div className=\"flex\">\n           <input\n             type=\"text\"\n             value={message}\n             onChange={(e) => setMessage(e.target.value)}\n             disabled={disabled}\n             placeholder=\"메시지를 입력하세요...\"\n             className=\"flex-1 p-3 border rounded-l-lg focus:outline-none focus:ring-2\"\n             style={{ focusRing: characterColor }}\n           />\n           <button\n             type=\"submit\"\n             disabled={disabled || !message.trim()}\n             className=\"px-4 rounded-r-lg text-white\"\n             style={{ backgroundColor: characterColor, opacity: disabled ? 0.5 : 1 }}\n           >\n             전송\n           </button>\n         </div>\n       </form>\n     )\n   }\n   ```",
        "testStrategy": "1. 메시지 표시 및 스크롤 테스트\n2. 타이핑 효과 테스트\n3. 메시지 전송 및 응답 테스트\n4. 캐릭터별 테마 적용 테스트\n5. 모바일 환경 테스트 (터치 인터랙션, 키보드 등)\n6. 긴 메시지 처리 테스트",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Why 문장 생성 알고리즘 구현",
        "description": "사용자 답변을 바탕으로 개인화된 Why 문장을 생성하는 알고리즘 구현",
        "details": "1. Why 문장 생성 프롬프트 설계:\n   ```typescript\n   // lib/why-generation.ts\n   import openai from './openai'\n   import { getSessionMessages } from './messages'\n   \n   export async function generateWhyStatement(sessionId: string) {\n     // 세션의 모든 메시지 가져오기\n     const messages = await getSessionMessages(sessionId)\n     \n     // 사용자 응답만 추출\n     const userResponses = messages\n       .filter(msg => msg.role === 'user')\n       .map(msg => msg.content)\n       .join('\\n\\n')\n     \n     // Why 문장 생성 프롬프트\n     const prompt = `\n     다음은 사용자가 8단계 질문에 응답한 내용입니다:\n     \n     ${userResponses}\n     \n     위 응답을 바탕으로 사용자의 개인화된 Why 문장을 생성해주세요.\n     Why 문장은 다음 형식을 따라야 합니다: \"[방법/스타일]함으로써 [궁극적 감정 상태][세상/사람들에게][~한다]\"\n     \n     예시:\n     - \"깊은 공감으로 소통함으로써 따뜻한 연결감을 사람들에게 전한다\"\n     - \"창의적인 문제 해결을 통해 새로운 가능성을 세상에 제시한다\"\n     - \"진정성 있는 대화를 나눔으로써 서로의 성장을 돕는다\"\n     \n     사용자의 응답에서 드러난 핵심 가치, 감정, 동기를 반영한 Why 문장을 생성해주세요.\n     Why 문장은 간결하고 명확하게, 그리고 사용자의 고유한 특성을 담아야 합니다.\n     `\n     \n     // OpenAI API 호출\n     const completion = await openai.chat.completions.create({\n       model: \"gpt-4o\",\n       messages: [\n         { role: \"system\", content: \"당신은 사용자의 Why 문장을 생성하는 전문가입니다.\" },\n         { role: \"user\", content: prompt }\n       ],\n       temperature: 0.7,\n     })\n     \n     return completion.choices[0].message.content\n   }\n   ```\n2. Why 문장 생성 API 엔드포인트:\n   ```typescript\n   // app/api/why-generation/route.ts\n   import { NextRequest, NextResponse } from 'next/server'\n   import { generateWhyStatement } from '@/lib/why-generation'\n   import { addMessage } from '@/lib/messages'\n   import { updateSessionStatus } from '@/lib/sessions'\n   \n   export async function POST(req: NextRequest) {\n     try {\n       const { sessionId } = await req.json()\n       \n       // Why 문장 생성\n       const whyStatement = await generateWhyStatement(sessionId)\n       \n       // 생성된 Why 문장을 메시지로 저장\n       await addMessage(sessionId, 'assistant', whyStatement, 'main')\n       \n       // 세션 상태 업데이트\n       await updateSessionStatus(sessionId, 'completed')\n       \n       return NextResponse.json({ whyStatement })\n     } catch (error) {\n       console.error('Why generation error:', error)\n       return NextResponse.json({ error: 'Failed to generate Why statement' }, { status: 500 })\n     }\n   }\n   ```\n3. Why 문장 표시 컴포넌트:\n   ```typescript\n   // components/consultation/WhyStatement.tsx\n   interface WhyStatementProps {\n     statement: string\n   }\n   \n   export function WhyStatement({ statement }: WhyStatementProps) {\n     return (\n       <div className=\"my-8 p-6 bg-gradient-to-r from-indigo-500 to-purple-600 rounded-lg text-white\">\n         <h2 className=\"text-xl font-bold mb-4 text-center\">당신의 Why</h2>\n         <p className=\"text-2xl font-medium text-center\">\"{statement}\"</p>\n       </div>\n     )\n   }\n   ```",
        "testStrategy": "1. 다양한 사용자 응답으로 Why 문장 생성 테스트\n2. 형식 준수 여부 검증\n3. 생성된 Why 문장의 품질 평가\n4. 오류 처리 및 예외 상황 테스트\n5. API 응답 시간 및 성능 테스트",
        "priority": "high",
        "dependencies": [
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "상담 히스토리 관리 시스템 구현",
        "description": "사용자별 상담 히스토리 저장, 조회, 관리 기능 구현",
        "details": "1. 히스토리 조회 API 구현:\n   ```typescript\n   // lib/history.ts\n   import { createSupabaseClient } from './supabase'\n   \n   export async function getUserConsultationHistory(userId: string) {\n     const supabase = createSupabaseClient()\n     \n     const { data, error } = await supabase\n       .from('sessions')\n       .select(`\n         id,\n         created_at,\n         updated_at,\n         status,\n         title,\n         messages!inner (id, content, role, character_type, created_at)\n       `)\n       .eq('user_id', userId)\n       .order('updated_at', { ascending: false })\n     \n     if (error) throw error\n     \n     // 각 세션의 마지막 메시지와 Why 문장 찾기\n     return data.map(session => {\n       const messages = session.messages || []\n       const lastMessage = messages.sort((a, b) => \n         new Date(b.created_at).getTime() - new Date(a.created_at).getTime()\n       )[0]\n       \n       // Why 문장 찾기 (마지막 assistant 메시지이면서 main 캐릭터인 경우)\n       const whyStatement = messages\n         .filter(m => m.role === 'assistant' && m.character_type === 'main')\n         .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())\n         [0]?.content || null\n       \n       return {\n         ...session,\n         lastMessage: lastMessage?.content || null,\n         whyStatement\n       }\n     })\n   }\n   \n   export async function getConsultationDetail(sessionId: string) {\n     const supabase = createSupabaseClient()\n     \n     const { data: session, error: sessionError } = await supabase\n       .from('sessions')\n       .select('*')\n       .eq('id', sessionId)\n       .single()\n     \n     if (sessionError) throw sessionError\n     \n     const { data: messages, error: messagesError } = await supabase\n       .from('messages')\n       .select('*')\n       .eq('session_id', sessionId)\n       .order('created_at', { ascending: true })\n     \n     if (messagesError) throw messagesError\n     \n     return {\n       ...session,\n       messages: messages || []\n     }\n   }\n   ```\n2. 히스토리 목록 컴포넌트:\n   ```typescript\n   // components/history/ConsultationHistoryList.tsx\n   interface ConsultationHistoryProps {\n     history: Array<{\n       id: string\n       title: string\n       created_at: string\n       status: string\n       lastMessage: string | null\n       whyStatement: string | null\n     }>\n     onSelectSession: (sessionId: string) => void\n   }\n   \n   export function ConsultationHistoryList({ history, onSelectSession }: ConsultationHistoryProps) {\n     return (\n       <div className=\"space-y-4\">\n         <h2 className=\"text-xl font-semibold\">상담 히스토리</h2>\n         \n         {history.length === 0 ? (\n           <p className=\"text-gray-500\">아직 상담 기록이 없습니다.</p>\n         ) : (\n           <div className=\"space-y-3\">\n             {history.map(session => (\n               <div \n                 key={session.id}\n                 onClick={() => onSelectSession(session.id)}\n                 className=\"p-4 border rounded-lg hover:bg-gray-50 cursor-pointer transition-colors\"\n               >\n                 <div className=\"flex justify-between items-start mb-2\">\n                   <h3 className=\"font-medium\">{session.title || '제목 없음'}</h3>\n                   <span className=\"text-xs px-2 py-1 rounded-full bg-gray-100\">\n                     {session.status === 'completed' ? '완료' : '진행 중'}\n                   </span>\n                 </div>\n                 \n                 <p className=\"text-sm text-gray-500 mb-2\">\n                   {new Date(session.created_at).toLocaleDateString()}\n                 </p>\n                 \n                 {session.whyStatement && (\n                   <div className=\"mt-2 p-2 bg-indigo-50 rounded text-sm\">\n                     <span className=\"font-medium\">Why: </span>\n                     {session.whyStatement}\n                   </div>\n                 )}\n                 \n                 {session.lastMessage && !session.whyStatement && (\n                   <p className=\"mt-2 text-sm text-gray-700 truncate\">\n                     {session.lastMessage}\n                   </p>\n                 )}\n               </div>\n             ))}\n           </div>\n         )}\n       </div>\n     )\n   }\n   ```\n3. 상담 상세 보기 페이지 구현",
        "testStrategy": "1. 히스토리 목록 조회 테스트\n2. 상담 상세 정보 조회 테스트\n3. 히스토리 필터링 및 정렬 테스트\n4. 페이지네이션 테스트 (많은 상담 기록 처리)\n5. 상담 삭제 및 수정 기능 테스트",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "반응형 UI 및 모바일 최적화",
        "description": "모바일과 데스크톱 환경 모두에 최적화된 반응형 UI 구현",
        "details": "1. 반응형 레이아웃 구현:\n   ```typescript\n   // components/layout/ResponsiveLayout.tsx\n   interface ResponsiveLayoutProps {\n     children: React.ReactNode\n   }\n   \n   export function ResponsiveLayout({ children }: ResponsiveLayoutProps) {\n     return (\n       <div className=\"min-h-screen bg-gradient-to-b from-gray-50 to-gray-100\">\n         <div className=\"max-w-4xl mx-auto px-4 sm:px-6 lg:px-8\">\n           {children}\n         </div>\n       </div>\n     )\n   }\n   ```\n2. 모바일 친화적 폰트 크기 및 패딩 설정:\n   ```css\n   /* styles/globals.css */\n   @layer base {\n     html {\n       font-size: 16px;\n     }\n     \n     @media (max-width: 640px) {\n       html {\n         font-size: 14px;\n       }\n     }\n     \n     body {\n       @apply text-gray-900 bg-gray-50;\n     }\n     \n     h1 {\n       @apply text-2xl sm:text-3xl font-bold;\n     }\n     \n     h2 {\n       @apply text-xl sm:text-2xl font-semibold;\n     }\n     \n     /* 기타 타이포그래피 설정 */\n   }\n   ```\n3. 모바일 터치 인터랙션 최적화:\n   ```typescript\n   // components/common/TouchFriendlyButton.tsx\n   interface TouchFriendlyButtonProps {\n     onClick: () => void\n     children: React.ReactNode\n     className?: string\n     disabled?: boolean\n   }\n   \n   export function TouchFriendlyButton({ \n     onClick, \n     children, \n     className = '', \n     disabled = false \n   }: TouchFriendlyButtonProps) {\n     return (\n       <button\n         onClick={onClick}\n         disabled={disabled}\n         className={`py-3 px-4 rounded-lg active:opacity-80 ${disabled ? 'opacity-50' : ''} ${className}`}\n         style={{ WebkitTapHighlightColor: 'transparent' }}\n       >\n         {children}\n       </button>\n     )\n   }\n   ```\n4. 모바일 키보드 처리:\n   ```typescript\n   // hooks/useKeyboardAware.ts\n   import { useState, useEffect } from 'react'\n   \n   export function useKeyboardAware() {\n     const [isKeyboardVisible, setIsKeyboardVisible] = useState(false)\n     \n     useEffect(() => {\n       const handleResize = () => {\n         // 모바일에서 키보드가 올라오면 viewport 높이가 줄어듦\n         const viewportHeight = window.visualViewport?.height || window.innerHeight\n         const windowHeight = window.innerHeight\n         \n         // 키보드가 올라왔다고 판단할 수 있는 임계값 (예: 30%)\n         setIsKeyboardVisible(viewportHeight < windowHeight * 0.7)\n       }\n       \n       window.visualViewport?.addEventListener('resize', handleResize)\n       return () => window.visualViewport?.removeEventListener('resize', handleResize)\n     }, [])\n     \n     return { isKeyboardVisible }\n   }\n   ```\n5. 미디어 쿼리를 활용한 레이아웃 조정:\n   ```typescript\n   // hooks/useMediaQuery.ts\n   import { useState, useEffect } from 'react'\n   \n   export function useMediaQuery(query: string) {\n     const [matches, setMatches] = useState(false)\n     \n     useEffect(() => {\n       const media = window.matchMedia(query)\n       setMatches(media.matches)\n       \n       const listener = (e: MediaQueryListEvent) => setMatches(e.matches)\n       media.addEventListener('change', listener)\n       \n       return () => media.removeEventListener('change', listener)\n     }, [query])\n     \n     return matches\n   }\n   ```",
        "testStrategy": "1. 다양한 화면 크기에서의 레이아웃 테스트\n2. 모바일 기기에서의 터치 인터랙션 테스트\n3. 키보드 표시/숨김에 따른 UI 조정 테스트\n4. 다양한 모바일 브라우저 호환성 테스트\n5. 접근성 테스트 (글꼴 크기, 색상 대비 등)",
        "priority": "medium",
        "dependencies": [
          4,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "성능 최적화 및 로딩 상태 관리",
        "description": "애플리케이션 성능 최적화 및 사용자 경험을 위한 로딩 상태 관리 구현",
        "details": "1. 이미지 최적화:\n   ```typescript\n   // components/common/OptimizedImage.tsx\n   import Image from 'next/image'\n   \n   interface OptimizedImageProps {\n     src: string\n     alt: string\n     width?: number\n     height?: number\n     className?: string\n   }\n   \n   export function OptimizedImage({ \n     src, \n     alt, \n     width, \n     height, \n     className = '' \n   }: OptimizedImageProps) {\n     return (\n       <div className={`relative ${className}`}>\n         <Image\n           src={src}\n           alt={alt}\n           width={width}\n           height={height}\n           loading=\"lazy\"\n           className=\"object-cover\"\n         />\n       </div>\n     )\n   }\n   ```\n2. 로딩 상태 컴포넌트:\n   ```typescript\n   // components/common/LoadingSpinner.tsx\n   interface LoadingSpinnerProps {\n     size?: 'small' | 'medium' | 'large'\n     color?: string\n   }\n   \n   export function LoadingSpinner({ \n     size = 'medium', \n     color = '#6366f1' \n   }: LoadingSpinnerProps) {\n     const sizeClass = {\n       small: 'w-4 h-4',\n       medium: 'w-8 h-8',\n       large: 'w-12 h-12'\n     }\n     \n     return (\n       <div className=\"flex justify-center items-center\">\n         <div \n           className={`${sizeClass[size]} rounded-full border-2 border-t-transparent animate-spin`}\n           style={{ borderColor: `${color}40`, borderTopColor: color }}\n         />\n       </div>\n     )\n   }\n   ```\n3. 컴포넌트 지연 로딩:\n   ```typescript\n   // app/page.tsx\n   import dynamic from 'next/dynamic'\n   \n   // 지연 로딩할 컴포넌트\n   const DynamicConsultationHistory = dynamic(\n     () => import('@/components/history/ConsultationHistoryList').then(mod => mod.ConsultationHistoryList),\n     { \n       loading: () => <LoadingSpinner size=\"large\" />,\n       ssr: false\n     }\n   )\n   ```\n4. 데이터 캐싱 및 재검증:\n   ```typescript\n   // lib/cache.ts\n   import { cache } from 'react'\n   import { getUserConsultationHistory } from './history'\n   \n   export const getCachedUserHistory = cache(async (userId: string) => {\n     return await getUserConsultationHistory(userId)\n   })\n   ```\n5. 스켈레톤 로딩 UI:\n   ```typescript\n   // components/common/SkeletonLoader.tsx\n   interface SkeletonLoaderProps {\n     count?: number\n     type: 'card' | 'text' | 'circle'\n     className?: string\n   }\n   \n   export function SkeletonLoader({ \n     count = 1, \n     type, \n     className = '' \n   }: SkeletonLoaderProps) {\n     const items = Array.from({ length: count }, (_, i) => i)\n     \n     const getTypeClass = () => {\n       switch (type) {\n         case 'card':\n           return 'h-32 rounded-lg'\n         case 'text':\n           return 'h-4 rounded'\n         case 'circle':\n           return 'h-10 w-10 rounded-full'\n       }\n     }\n     \n     return (\n       <div className=\"space-y-3\">\n         {items.map(i => (\n           <div \n             key={i}\n             className={`bg-gray-200 animate-pulse ${getTypeClass()} ${className}`}\n           />\n         ))}\n       </div>\n     )\n   }\n   ```",
        "testStrategy": "1. 페이지 로드 시간 측정 및 최적화\n2. 이미지 로딩 성능 테스트\n3. 로딩 상태 UI 테스트\n4. 데이터 캐싱 효과 검증\n5. 네트워크 지연 상황에서의 UX 테스트\n6. Lighthouse 성능 점수 측정",
        "priority": "medium",
        "dependencies": [
          10,
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "배포 및 환경 설정",
        "description": "Vercel을 통한 배포 및 개발/프로덕션 환경 설정",
        "details": "1. 환경 변수 설정:\n   ```\n   # .env.development\n   NEXT_PUBLIC_SUPABASE_URL=your_development_supabase_url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your_development_anon_key\n   SUPABASE_SERVICE_ROLE_KEY=your_development_service_key\n   OPENAI_API_KEY=your_development_openai_key\n   \n   # .env.production\n   NEXT_PUBLIC_SUPABASE_URL=your_production_supabase_url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your_production_anon_key\n   SUPABASE_SERVICE_ROLE_KEY=your_production_service_key\n   OPENAI_API_KEY=your_production_openai_key\n   ```\n2. Vercel 배포 설정 (vercel.json):\n   ```json\n   {\n     \"framework\": \"nextjs\",\n     \"buildCommand\": \"next build\",\n     \"devCommand\": \"next dev\",\n     \"installCommand\": \"npm install\",\n     \"outputDirectory\": \".next\",\n     \"regions\": [\"icn1\"],\n     \"headers\": [\n       {\n         \"source\": \"/(.*)\",\n         \"headers\": [\n           {\n             \"key\": \"X-Content-Type-Options\",\n             \"value\": \"nosniff\"\n           },\n           {\n             \"key\": \"X-Frame-Options\",\n             \"value\": \"DENY\"\n           },\n           {\n             \"key\": \"X-XSS-Protection\",\n             \"value\": \"1; mode=block\"\n           }\n         ]\n       }\n     ]\n   }\n   ```\n3. GitHub Actions CI/CD 설정 (.github/workflows/ci.yml):\n   ```yaml\n   name: CI/CD Pipeline\n   \n   on:\n     push:\n       branches: [main]\n     pull_request:\n       branches: [main]\n   \n   jobs:\n     build-and-test:\n       runs-on: ubuntu-latest\n       \n       steps:\n         - uses: actions/checkout@v3\n         \n         - name: Setup Node.js\n           uses: actions/setup-node@v3\n           with:\n             node-version: '18'\n             cache: 'npm'\n         \n         - name: Install dependencies\n           run: npm ci\n         \n         - name: Lint\n           run: npm run lint\n         \n         - name: Type check\n           run: npm run type-check\n         \n         - name: Build\n           run: npm run build\n   ```\n4. 배포 스크립트 (package.json):\n   ```json\n   {\n     \"scripts\": {\n       \"dev\": \"next dev\",\n       \"build\": \"next build\",\n       \"start\": \"next start\",\n       \"lint\": \"next lint\",\n       \"type-check\": \"tsc --noEmit\",\n       \"deploy:staging\": \"vercel\",\n       \"deploy:production\": \"vercel --prod\"\n     }\n   }\n   ```\n5. 에러 모니터링 설정 (Sentry 등)",
        "testStrategy": "1. 개발/프로덕션 환경 변수 분리 테스트\n2. Vercel 배포 테스트\n3. CI/CD 파이프라인 테스트\n4. 보안 헤더 설정 확인\n5. 배포 후 성능 모니터링\n6. 에러 로깅 및 모니터링 테스트",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-18T05:37:51.615Z",
      "updated": "2025-08-18T05:41:12.899Z",
      "description": "Tasks for master context"
    }
  }
}