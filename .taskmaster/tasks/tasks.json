{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Next.js 15 프로젝트 초기 설정",
        "description": "Next.js 15 App Router를 사용한 프로젝트 구조 설정 및 기본 의존성 설치",
        "details": "1. Node.js v18+ 환경 확인\n2. `npx create-next-app@latest` 명령어로 프로젝트 생성\n3. TypeScript, Tailwind CSS, ESLint 옵션 선택\n4. App Router 구조 선택\n5. 주요 의존성 설치:\n   - `@supabase/ssr`\n   - `openai`\n   - `class-variance-authority`\n   - `@radix-ui` 컴포넌트\n6. 환경 변수 파일 (.env.local) 설정:\n   - NEXT_PUBLIC_SUPABASE_URL\n   - NEXT_PUBLIC_SUPABASE_ANON_KEY\n   - SUPABASE_SERVICE_ROLE_KEY\n   - OPENAI_API_KEY\n7. 기본 폴더 구조 설정:\n   - app/ (라우팅)\n   - components/ (UI 컴포넌트)\n   - lib/ (유틸리티 함수)\n   - types/ (TypeScript 타입 정의)\n   - styles/ (글로벌 스타일)",
        "testStrategy": "1. 프로젝트가 오류 없이 빌드되는지 확인\n2. 개발 서버 실행 후 기본 페이지 로드 확인\n3. 환경 변수가 올바르게 로드되는지 확인\n4. TypeScript 타입 체크 통과 확인",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Supabase 연동 및 데이터베이스 스키마 설정",
        "description": "Supabase 프로젝트 설정 및 필요한 테이블 스키마 구성",
        "details": "1. Supabase 프로젝트 생성\n2. 다음 테이블 스키마 설정:\n   - users: id(PK), email, created_at, updated_at\n   - sessions: id(PK), user_id(FK), title, created_at, updated_at, status\n   - messages: id(PK), session_id(FK), role(user/assistant), content, character_type, created_at\n   - payments: id(PK), user_id(FK), amount, status, created_at\n3. Row Level Security (RLS) 정책 설정:\n   - users: 자신의 데이터만 읽기/쓰기 가능\n   - sessions: 소유자만 읽기/쓰기 가능\n   - messages: 세션 소유자만 읽기/쓰기 가능\n4. 인덱스 설정:\n   - sessions: user_id, created_at\n   - messages: session_id, created_at\n5. Supabase 클라이언트 설정 (lib/supabase.ts):\n   ```typescript\n   import { createClient } from '@supabase/ssr'\n   \n   export const createSupabaseClient = () => {\n     return createClient(\n       process.env.NEXT_PUBLIC_SUPABASE_URL!,\n       process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n     )\n   }\n   ```",
        "testStrategy": "1. 테이블 생성 및 관계 설정 검증\n2. RLS 정책 테스트 (권한 없는 사용자의 접근 차단 확인)\n3. 테스트 데이터 삽입 및 조회 테스트\n4. Supabase 클라이언트 연결 테스트",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "사용자 인증 시스템 구현",
        "description": "Supabase Auth를 활용한 이메일 기반 회원가입/로그인 시스템 구현",
        "details": "1. 인증 관련 컴포넌트 생성:\n   - components/auth/LoginForm.tsx\n   - components/auth/SignupForm.tsx\n   - components/auth/AuthLayout.tsx\n2. 인증 페이지 생성:\n   - app/login/page.tsx\n   - app/signup/page.tsx\n3. Supabase Auth 통합:\n   ```typescript\n   // lib/auth.ts\n   import { createSupabaseClient } from './supabase'\n   \n   export async function signUp(email: string, password: string) {\n     const supabase = createSupabaseClient()\n     return await supabase.auth.signUp({ email, password })\n   }\n   \n   export async function signIn(email: string, password: string) {\n     const supabase = createSupabaseClient()\n     return await supabase.auth.signInWithPassword({ email, password })\n   }\n   \n   export async function signOut() {\n     const supabase = createSupabaseClient()\n     return await supabase.auth.signOut()\n   }\n   ```\n4. 인증 상태 관리 미들웨어 구현 (middleware.ts)\n5. 보호된 라우트 설정 (로그인 필요한 페이지)",
        "testStrategy": "1. 회원가입 플로우 테스트 (이메일 검증 포함)\n2. 로그인/로그아웃 기능 테스트\n3. 보호된 라우트 접근 제한 테스트\n4. 인증 오류 처리 및 사용자 피드백 테스트\n5. 세션 지속성 테스트 (페이지 새로고침 후)",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "대시보드 페이지 구현",
        "description": "사용자의 진행 중인 상담과 완료된 상담 목록을 표시하는 대시보드 페이지 구현",
        "details": "1. 대시보드 페이지 생성 (app/page.tsx)\n2. 세션 목록 컴포넌트 구현:\n   ```typescript\n   // components/dashboard/SessionList.tsx\n   import { Session } from '@/types'\n   \n   interface SessionListProps {\n     sessions: Session[]\n     type: 'active' | 'completed'\n     onSessionSelect: (sessionId: string) => void\n   }\n   \n   export function SessionList({ sessions, type, onSessionSelect }: SessionListProps) {\n     return (\n       <div className=\"space-y-4\">\n         <h2 className=\"text-xl font-semibold\">\n           {type === 'active' ? '진행 중인 상담' : '완료된 상담'}\n         </h2>\n         <div className=\"space-y-2\">\n           {sessions.map((session) => (\n             <div \n               key={session.id}\n               onClick={() => onSessionSelect(session.id)}\n               className=\"p-4 border rounded-lg hover:bg-gray-50 cursor-pointer\"\n             >\n               <h3 className=\"font-medium\">{session.title || '제목 없음'}</h3>\n               <p className=\"text-sm text-gray-500\">\n                 {new Date(session.created_at).toLocaleDateString()}\n               </p>\n               {session.last_message && (\n                 <p className=\"mt-2 text-sm truncate\">{session.last_message}</p>\n               )}\n             </div>\n           ))}\n         </div>\n       </div>\n     )\n   }\n   ```\n3. \"새 상담 시작\" 버튼 구현\n4. 세션 데이터 가져오는 API 구현:\n   ```typescript\n   // lib/sessions.ts\n   import { createSupabaseClient } from './supabase'\n   \n   export async function getUserSessions(userId: string) {\n     const supabase = createSupabaseClient()\n     \n     const { data: sessions, error } = await supabase\n       .from('sessions')\n       .select('*, messages(content, created_at)')\n       .eq('user_id', userId)\n       .order('created_at', { ascending: false })\n     \n     if (error) throw error\n     \n     return sessions.map(session => ({\n       ...session,\n       last_message: session.messages?.[0]?.content || null\n     }))\n   }\n   ```\n5. 세션 선택 시 해당 상담 페이지로 이동하는 기능",
        "testStrategy": "1. 세션 목록 데이터 로딩 테스트\n2. 세션 필터링 (진행 중/완료) 기능 테스트\n3. 세션 선택 시 올바른 페이지로 이동하는지 테스트\n4. \"새 상담 시작\" 버튼 기능 테스트\n5. 로딩 상태 및 오류 처리 테스트\n6. 반응형 디자인 테스트 (모바일/데스크톱)",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "상담 세션 관리 시스템 구현",
        "description": "상담 세션 생성, 저장, 이어서 진행하는 기능 구현",
        "details": "1. 세션 관리 API 구현:\n   ```typescript\n   // lib/sessions.ts\n   export async function createSession(userId: string) {\n     const supabase = createSupabaseClient()\n     \n     const { data, error } = await supabase\n       .from('sessions')\n       .insert({\n         user_id: userId,\n         status: 'active',\n         title: `상담 ${new Date().toLocaleDateString()}`\n       })\n       .select()\n     \n     if (error) throw error\n     return data[0]\n   }\n   \n   export async function getSessionById(sessionId: string) {\n     const supabase = createSupabaseClient()\n     \n     const { data, error } = await supabase\n       .from('sessions')\n       .select('*')\n       .eq('id', sessionId)\n       .single()\n     \n     if (error) throw error\n     return data\n   }\n   \n   export async function updateSessionStatus(sessionId: string, status: 'active' | 'completed') {\n     const supabase = createSupabaseClient()\n     \n     const { error } = await supabase\n       .from('sessions')\n       .update({ status })\n       .eq('id', sessionId)\n     \n     if (error) throw error\n     return true\n   }\n   ```\n2. 세션 메시지 관리 API 구현:\n   ```typescript\n   // lib/messages.ts\n   export async function getSessionMessages(sessionId: string) {\n     const supabase = createSupabaseClient()\n     \n     const { data, error } = await supabase\n       .from('messages')\n       .select('*')\n       .eq('session_id', sessionId)\n       .order('created_at', { ascending: true })\n     \n     if (error) throw error\n     return data\n   }\n   \n   export async function addMessage(sessionId: string, role: 'user' | 'assistant', content: string, character_type?: string) {\n     const supabase = createSupabaseClient()\n     \n     const { data, error } = await supabase\n       .from('messages')\n       .insert({\n         session_id: sessionId,\n         role,\n         content,\n         character_type\n       })\n       .select()\n     \n     if (error) throw error\n     return data[0]\n   }\n   ```\n3. 세션 상태 관리 (진행 중/완료) 기능 구현",
        "testStrategy": "1. 세션 생성 기능 테스트\n2. 세션 상태 업데이트 테스트\n3. 세션 메시지 저장 및 조회 테스트\n4. 세션 간 전환 시 데이터 일관성 테스트\n5. 동시성 이슈 테스트 (여러 탭에서 동일 세션 접근)",
        "priority": "high",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "온보딩/튜토리얼 시스템 구현",
        "description": "새 상담 시작 시 제공되는 풀스크린 게임적 UI/UX 튜토리얼 시스템 구현",
        "details": "1. 온보딩 컴포넌트 구현:\n   ```typescript\n   // components/onboarding/OnboardingScreen.tsx\n   import { useState } from 'react'\n   \n   const ONBOARDING_STEPS = [\n     {\n       title: '환영합니다!',\n       message: '메인 캐릭터가 상담을 진행합니다.',\n       character: 'main'\n     },\n     {\n       title: '편안한 환경을 만드세요',\n       message: '가장 마음이 차분해지는 곳으로 가서 마음에 드는 노래를 틀어보세요.',\n       character: 'main'\n     },\n     {\n       title: '당신의 Why를 찾아봐요',\n       message: '내 인생의 가장 중요한 한마디를 찾아가는 것입니다.',\n       character: 'main'\n     },\n     {\n       title: '천천히 진행하세요',\n       message: '한번에 정확하게 모두 찾을 수 있을 거라 생각하지 마세요.',\n       character: 'main'\n     },\n     {\n       title: '꾸준히 해보세요',\n       message: '적어도 5번은 해보세요.',\n       character: 'main'\n     },\n     {\n       title: '자기 자신에게 집중하세요',\n       message: '그 과정에서 나도 모르게 나에게 집중하고 있다는 것을 알게 될 것입니다.',\n       character: 'main'\n     }\n   ]\n   \n   export function OnboardingScreen({ onComplete }: { onComplete: () => void }) {\n     const [currentStep, setCurrentStep] = useState(0)\n     \n     const nextStep = () => {\n       if (currentStep < ONBOARDING_STEPS.length - 1) {\n         setCurrentStep(currentStep + 1)\n       } else {\n         onComplete()\n       }\n     }\n     \n     const step = ONBOARDING_STEPS[currentStep]\n     \n     return (\n       <div className=\"fixed inset-0 bg-gradient-to-b from-indigo-500 to-purple-600 flex items-center justify-center z-50\">\n         <div className=\"max-w-md w-full p-6 bg-white rounded-lg shadow-xl\">\n           <div className=\"mb-6 flex justify-center\">\n             {/* Character image based on step.character */}\n             <div className=\"w-24 h-24 rounded-full bg-indigo-100 flex items-center justify-center\">\n               {step.character === 'main' && '🌟'}\n             </div>\n           </div>\n           \n           <h2 className=\"text-2xl font-bold text-center mb-4\">{step.title}</h2>\n           <p className=\"text-center text-gray-700 mb-8\">{step.message}</p>\n           \n           <div className=\"flex justify-center\">\n             <button \n               onClick={nextStep}\n               className=\"px-6 py-2 bg-indigo-600 text-white rounded-full hover:bg-indigo-700 transition-colors\"\n             >\n               {currentStep < ONBOARDING_STEPS.length - 1 ? '다음' : '시작하기'}\n             </button>\n           </div>\n           \n           <div className=\"mt-6 flex justify-center space-x-2\">\n             {ONBOARDING_STEPS.map((_, index) => (\n               <div \n                 key={index}\n                 className={`w-2 h-2 rounded-full ${index === currentStep ? 'bg-indigo-600' : 'bg-gray-300'}`}\n               />\n             ))}\n           </div>\n         </div>\n       </div>\n     )\n   }\n   ```\n2. 온보딩 상태 관리 (완료 여부 저장)\n3. 게임적 UI/UX 요소 추가 (애니메이션, 사운드 효과 등)\n4. 온보딩 완료 후 상담 시작 연결",
        "testStrategy": "1. 온보딩 단계별 진행 테스트\n2. 온보딩 완료 상태 저장 및 확인 테스트\n3. 모바일/데스크톱 환경에서의 UI 테스트\n4. 애니메이션 및 전환 효과 테스트\n5. 사용자 인터랙션 테스트 (버튼 클릭, 스와이프 등)",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "상담사 캐릭터 시스템 구현",
        "description": "메인 상담사와 3개의 특화된 상담사 캐릭터 시스템 구현",
        "details": "1. 캐릭터 타입 정의:\n   ```typescript\n   // types/characters.ts\n   export type CharacterType = 'main' | 'yellow' | 'bibi' | 'green'\n   \n   export interface Character {\n     type: CharacterType\n     emoji: string\n     name: string\n     description: string\n     color: string\n     gradientFrom: string\n     gradientTo: string\n     tone: string\n   }\n   ```\n2. 캐릭터 데이터 정의:\n   ```typescript\n   // lib/characters.ts\n   import { Character } from '@/types/characters'\n   \n   export const CHARACTERS: Record<CharacterType, Character> = {\n     main: {\n       type: 'main',\n       emoji: '🌟',\n       name: '메인 상담사',\n       description: '인트로, Why 생성, 전체 진행 관리',\n       color: '#6366f1', // indigo-500\n       gradientFrom: '#818cf8', // indigo-400\n       gradientTo: '#4f46e5', // indigo-600\n       tone: '친절하고 안내하는 톤'\n     },\n     yellow: {\n       type: 'yellow',\n       emoji: '🌞',\n       name: '옐로',\n       description: '뿌듯함, 보람 관련 질문',\n       color: '#facc15', // yellow-400\n       gradientFrom: '#fef08a', // yellow-200\n       gradientTo: '#eab308', // yellow-500\n       tone: '밝고 긍정적인 톤'\n     },\n     bibi: {\n       type: 'bibi',\n       emoji: '🦋',\n       name: '비비',\n       description: '감정, 좋은/힘든 순간 탐구',\n       color: '#3b82f6', // blue-500\n       gradientFrom: '#93c5fd', // blue-300\n       gradientTo: '#2563eb', // blue-600\n       tone: '차분하고 깊이 있는 톤'\n     },\n     green: {\n       type: 'green',\n       emoji: '🌿',\n       name: '그린',\n       description: '꿈과 비전 탐구',\n       color: '#22c55e', // green-500\n       gradientFrom: '#86efac', // green-300\n       gradientTo: '#16a34a', // green-600\n       tone: '자연스럽고 안정적인 톤'\n     }\n   }\n   ```\n3. 캐릭터별 메시지 버블 컴포넌트 구현:\n   ```typescript\n   // components/chat/CharacterMessage.tsx\n   import { Character } from '@/types/characters'\n   \n   interface CharacterMessageProps {\n     character: Character\n     message: string\n     isTyping?: boolean\n   }\n   \n   export function CharacterMessage({ character, message, isTyping = false }: CharacterMessageProps) {\n     return (\n       <div className=\"flex items-start mb-4\">\n         <div \n           className=\"w-10 h-10 rounded-full flex items-center justify-center mr-3\"\n           style={{ background: character.color }}\n         >\n           <span className=\"text-lg\">{character.emoji}</span>\n         </div>\n         \n         <div \n           className=\"max-w-[80%] p-3 rounded-lg\"\n           style={{ \n             background: `linear-gradient(to bottom right, ${character.gradientFrom}, ${character.gradientTo})`,\n             color: 'white'\n           }}\n         >\n           <div className=\"font-medium mb-1\">{character.name}</div>\n           <div>\n             {isTyping ? (\n               <span className=\"inline-flex items-center\">\n                 <span className=\"typing-dot\"></span>\n                 <span className=\"typing-dot\"></span>\n                 <span className=\"typing-dot\"></span>\n               </span>\n             ) : (\n               message\n             )}\n           </div>\n         </div>\n       </div>\n     )\n   }\n   ```\n4. 캐릭터 전환 로직 구현 (질문 단계에 따라)",
        "testStrategy": "1. 각 캐릭터 렌더링 테스트\n2. 캐릭터별 스타일 적용 확인\n3. 캐릭터 전환 로직 테스트\n4. 타이핑 효과 테스트\n5. 반응형 디자인 테스트",
        "priority": "medium",
        "dependencies": [
          1,
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "OpenAI Assistant API 통합",
        "description": "OpenAI GPT-4o와 Assistant API를 활용한 상담 AI 통합",
        "details": "1. OpenAI 클라이언트 설정:\n   ```typescript\n   // lib/openai.ts\n   import OpenAI from 'openai'\n   \n   const openai = new OpenAI({\n     apiKey: process.env.OPENAI_API_KEY\n   })\n   \n   export default openai\n   ```\n2. Assistant 생성 및 관리:\n   ```typescript\n   // lib/assistant.ts\n   import openai from './openai'\n   \n   // 캐릭터별 Assistant 생성 함수\n   export async function createOrGetAssistant(characterType: CharacterType) {\n     // 실제 구현에서는 이미 생성된 Assistant ID를 환경변수나 DB에서 가져오는 것이 좋음\n     const assistantId = process.env[`OPENAI_${characterType.toUpperCase()}_ASSISTANT_ID`]\n     \n     if (assistantId) {\n       return assistantId\n     }\n     \n     // 새 Assistant 생성 (개발/테스트용)\n     const character = CHARACTERS[characterType]\n     \n     const assistant = await openai.beta.assistants.create({\n       name: `Why 상담사 - ${character.name}`,\n       instructions: `당신은 Why 상담사의 ${character.name} 캐릭터입니다. ${character.description}을 담당합니다. ${character.tone}으로 대화하세요.`,\n       model: \"gpt-4o\",\n     })\n     \n     return assistant.id\n   }\n   \n   // Thread 생성\n   export async function createThread() {\n     const thread = await openai.beta.threads.create()\n     return thread.id\n   }\n   \n   // 메시지 추가\n   export async function addMessageToThread(threadId: string, content: string, role: 'user' | 'assistant' = 'user') {\n     const message = await openai.beta.threads.messages.create(threadId, {\n       role,\n       content\n     })\n     return message\n   }\n   \n   // 응답 생성\n   export async function runAssistant(threadId: string, assistantId: string) {\n     const run = await openai.beta.threads.runs.create(threadId, {\n       assistant_id: assistantId\n     })\n     \n     // 완료될 때까지 대기\n     let runStatus = await openai.beta.threads.runs.retrieve(threadId, run.id)\n     \n     while (runStatus.status !== 'completed') {\n       await new Promise(resolve => setTimeout(resolve, 1000))\n       runStatus = await openai.beta.threads.runs.retrieve(threadId, run.id)\n       \n       if (runStatus.status === 'failed') {\n         throw new Error('Assistant run failed')\n       }\n     }\n     \n     // 응답 메시지 가져오기\n     const messages = await openai.beta.threads.messages.list(threadId)\n     return messages.data[0].content[0].text.value\n   }\n   ```\n3. API 라우트 구현:\n   ```typescript\n   // app/api/chat/route.ts\n   import { NextRequest, NextResponse } from 'next/server'\n   import { createOrGetAssistant, createThread, addMessageToThread, runAssistant } from '@/lib/assistant'\n   import { addMessage } from '@/lib/messages'\n   \n   export async function POST(req: NextRequest) {\n     try {\n       const { sessionId, message, characterType, threadId: existingThreadId } = await req.json()\n       \n       // Thread ID 가져오기 또는 생성\n       const threadId = existingThreadId || await createThread()\n       \n       // Assistant ID 가져오기\n       const assistantId = await createOrGetAssistant(characterType)\n       \n       // 사용자 메시지 추가\n       await addMessageToThread(threadId, message)\n       \n       // DB에 사용자 메시지 저장\n       await addMessage(sessionId, 'user', message)\n       \n       // 응답 생성\n       const response = await runAssistant(threadId, assistantId)\n       \n       // DB에 AI 응답 저장\n       await addMessage(sessionId, 'assistant', response, characterType)\n       \n       return NextResponse.json({ \n         threadId,\n         response,\n         characterType\n       })\n     } catch (error) {\n       console.error('Chat API error:', error)\n       return NextResponse.json({ error: 'Failed to process chat' }, { status: 500 })\n     }\n   }\n   ```",
        "testStrategy": "1. OpenAI API 연결 테스트\n2. Assistant 생성 및 관리 테스트\n3. Thread 생성 및 메시지 추가 테스트\n4. 응답 생성 및 처리 테스트\n5. 오류 처리 및 재시도 메커니즘 테스트\n6. 토큰 사용량 모니터링",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "구조화된 8단계 질문 시스템 구현",
        "description": "상담 과정의 8단계 질문 시스템 및 단계별 캐릭터 전환 구현",
        "details": "1. 상담 단계 정의:\n   ```typescript\n   // types/consultation.ts\n   export type ConsultationStage = \n     | 'intro'\n     | 'question1'\n     | 'question2'\n     | 'question3'\n     | 'question4'\n     | 'question5'\n     | 'question6'\n     | 'question7'\n     | 'question8'\n     | 'why_generation'\n     | 'completed'\n   \n   export interface StageConfig {\n     stage: ConsultationStage\n     character: CharacterType\n     title: string\n     description: string\n     initialPrompt: string\n   }\n   ```\n2. 단계별 설정 정의:\n   ```typescript\n   // lib/consultation-stages.ts\n   import { StageConfig } from '@/types/consultation'\n   \n   export const CONSULTATION_STAGES: StageConfig[] = [\n     {\n       stage: 'intro',\n       character: 'main',\n       title: '상담 시작',\n       description: '상담 안내 및 준비',\n       initialPrompt: '안녕하세요! Why 상담사입니다. 오늘 당신의 진정한 Why를 찾아보는 여정을 함께 하겠습니다. 준비되셨나요?'\n     },\n     {\n       stage: 'question1',\n       character: 'yellow',\n       title: '뿌듯함과 보람',\n       description: '뿌듯함을 느꼈던 순간들',\n       initialPrompt: '안녕하세요, 저는 옐로예요! 당신이 가장 뿌듯함과 보람을 느꼈던 순간들에 대해 이야기해 볼까요? 어떤 일을 했을 때 가장 큰 성취감을 느끼셨나요?'\n     },\n     // 나머지 단계 정의...\n     {\n       stage: 'why_generation',\n       character: 'main',\n       title: 'Why 문장 생성',\n       description: '개인화된 Why 문장 도출',\n       initialPrompt: '지금까지의 대화를 바탕으로 당신의 Why 문장을 만들어 보겠습니다. \"[방법/스타일]함으로써 [궁극적 감정 상태][세상/사람들에게][~한다]\" 형태로 정리해 드릴게요.'\n     }\n   ]\n   ```\n3. 상담 진행 관리 컴포넌트:\n   ```typescript\n   // components/consultation/ConsultationManager.tsx\n   import { useState, useEffect } from 'react'\n   import { ConsultationStage } from '@/types/consultation'\n   import { CONSULTATION_STAGES } from '@/lib/consultation-stages'\n   \n   export function ConsultationManager({ sessionId }: { sessionId: string }) {\n     const [currentStage, setCurrentStage] = useState<ConsultationStage>('intro')\n     const [threadId, setThreadId] = useState<string | null>(null)\n     \n     const stageConfig = CONSULTATION_STAGES.find(s => s.stage === currentStage)!\n     \n     // 단계 진행 함수\n     const advanceToNextStage = () => {\n       const currentIndex = CONSULTATION_STAGES.findIndex(s => s.stage === currentStage)\n       if (currentIndex < CONSULTATION_STAGES.length - 1) {\n         setCurrentStage(CONSULTATION_STAGES[currentIndex + 1].stage)\n       }\n     }\n     \n     // 나머지 구현...\n   }\n   ```\n4. 단계별 프롬프트 및 지시사항 관리",
        "testStrategy": "1. 각 상담 단계 전환 테스트\n2. 단계별 캐릭터 전환 테스트\n3. 단계별 초기 프롬프트 전송 테스트\n4. 상담 진행 상태 저장 및 복원 테스트\n5. 단계 건너뛰기 및 이전 단계로 돌아가기 테스트",
        "priority": "high",
        "dependencies": [
          7,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "실시간 대화 인터페이스 구현",
        "description": "타이핑 효과와 캐릭터별 테마가 적용된 실시간 대화 인터페이스 구현",
        "details": "1. 채팅 인터페이스 컴포넌트:\n   ```typescript\n   // components/chat/ChatInterface.tsx\n   import { useState, useRef, useEffect } from 'react'\n   import { CharacterMessage } from './CharacterMessage'\n   import { UserMessage } from './UserMessage'\n   import { MessageInput } from './MessageInput'\n   import { Character } from '@/types/characters'\n   import { CHARACTERS } from '@/lib/characters'\n   \n   interface Message {\n     id: string\n     content: string\n     role: 'user' | 'assistant'\n     characterType?: CharacterType\n   }\n   \n   interface ChatInterfaceProps {\n     sessionId: string\n     currentCharacter: Character\n     onSendMessage: (message: string) => Promise<void>\n     messages: Message[]\n     isTyping: boolean\n   }\n   \n   export function ChatInterface({ \n     sessionId, \n     currentCharacter, \n     onSendMessage, \n     messages, \n     isTyping \n   }: ChatInterfaceProps) {\n     const messagesEndRef = useRef<HTMLDivElement>(null)\n     \n     // 스크롤 자동 이동\n     useEffect(() => {\n       messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })\n     }, [messages, isTyping])\n     \n     return (\n       <div className=\"flex flex-col h-full\">\n         <div \n           className=\"flex-1 overflow-y-auto p-4\"\n           style={{\n             background: `linear-gradient(to bottom, ${currentCharacter.gradientFrom}20, ${currentCharacter.gradientTo}10)`\n           }}\n         >\n           {messages.map(message => (\n             <div key={message.id}>\n               {message.role === 'user' ? (\n                 <UserMessage message={message.content} />\n               ) : (\n                 <CharacterMessage \n                   character={CHARACTERS[message.characterType || 'main']} \n                   message={message.content} \n                 />\n               )}\n             </div>\n           ))}\n           \n           {isTyping && (\n             <CharacterMessage \n               character={currentCharacter} \n               message=\"\" \n               isTyping={true} \n             />\n           )}\n           \n           <div ref={messagesEndRef} />\n         </div>\n         \n         <MessageInput \n           onSendMessage={onSendMessage} \n           disabled={isTyping} \n           characterColor={currentCharacter.color}\n         />\n       </div>\n     )\n   }\n   ```\n2. 타이핑 효과 구현:\n   ```typescript\n   // components/chat/TypingEffect.tsx\n   import { useState, useEffect } from 'react'\n   \n   export function TypingEffect({ text, speed = 30 }: { text: string, speed?: number }) {\n     const [displayedText, setDisplayedText] = useState('')\n     const [currentIndex, setCurrentIndex] = useState(0)\n     \n     useEffect(() => {\n       if (currentIndex < text.length) {\n         const timeout = setTimeout(() => {\n           setDisplayedText(prev => prev + text[currentIndex])\n           setCurrentIndex(prev => prev + 1)\n         }, speed)\n         \n         return () => clearTimeout(timeout)\n       }\n     }, [currentIndex, text, speed])\n     \n     useEffect(() => {\n       setDisplayedText('')\n       setCurrentIndex(0)\n     }, [text])\n     \n     return <span>{displayedText}</span>\n   }\n   ```\n3. 메시지 입력 컴포넌트:\n   ```typescript\n   // components/chat/MessageInput.tsx\n   import { useState } from 'react'\n   \n   interface MessageInputProps {\n     onSendMessage: (message: string) => Promise<void>\n     disabled: boolean\n     characterColor: string\n   }\n   \n   export function MessageInput({ onSendMessage, disabled, characterColor }: MessageInputProps) {\n     const [message, setMessage] = useState('')\n     \n     const handleSubmit = async (e: React.FormEvent) => {\n       e.preventDefault()\n       if (message.trim() && !disabled) {\n         setMessage('')\n         await onSendMessage(message)\n       }\n     }\n     \n     return (\n       <form onSubmit={handleSubmit} className=\"p-4 border-t bg-white\">\n         <div className=\"flex\">\n           <input\n             type=\"text\"\n             value={message}\n             onChange={(e) => setMessage(e.target.value)}\n             disabled={disabled}\n             placeholder=\"메시지를 입력하세요...\"\n             className=\"flex-1 p-3 border rounded-l-lg focus:outline-none focus:ring-2\"\n             style={{ focusRing: characterColor }}\n           />\n           <button\n             type=\"submit\"\n             disabled={disabled || !message.trim()}\n             className=\"px-4 rounded-r-lg text-white\"\n             style={{ backgroundColor: characterColor, opacity: disabled ? 0.5 : 1 }}\n           >\n             전송\n           </button>\n         </div>\n       </form>\n     )\n   }\n   ```",
        "testStrategy": "1. 메시지 표시 및 스크롤 테스트\n2. 타이핑 효과 테스트\n3. 메시지 전송 및 응답 테스트\n4. 캐릭터별 테마 적용 테스트\n5. 모바일 환경 테스트 (터치 인터랙션, 키보드 등)\n6. 긴 메시지 처리 테스트",
        "priority": "medium",
        "dependencies": [
          7,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Why 문장 생성 알고리즘 구현",
        "description": "사용자 답변을 바탕으로 개인화된 Why 문장을 생성하는 알고리즘 구현",
        "details": "1. Why 문장 생성 프롬프트 설계:\n   ```typescript\n   // lib/why-generation.ts\n   import openai from './openai'\n   import { getSessionMessages } from './messages'\n   \n   export async function generateWhyStatement(sessionId: string) {\n     // 세션의 모든 메시지 가져오기\n     const messages = await getSessionMessages(sessionId)\n     \n     // 사용자 응답만 추출\n     const userResponses = messages\n       .filter(msg => msg.role === 'user')\n       .map(msg => msg.content)\n       .join('\\n\\n')\n     \n     // Why 문장 생성 프롬프트\n     const prompt = `\n     다음은 사용자가 8단계 질문에 응답한 내용입니다:\n     \n     ${userResponses}\n     \n     위 응답을 바탕으로 사용자의 개인화된 Why 문장을 생성해주세요.\n     Why 문장은 다음 형식을 따라야 합니다: \"[방법/스타일]함으로써 [궁극적 감정 상태][세상/사람들에게][~한다]\"\n     \n     예시:\n     - \"깊은 공감으로 소통함으로써 따뜻한 연결감을 사람들에게 전한다\"\n     - \"창의적인 문제 해결을 통해 새로운 가능성을 세상에 제시한다\"\n     - \"진정성 있는 대화를 나눔으로써 서로의 성장을 돕는다\"\n     \n     사용자의 응답에서 드러난 핵심 가치, 감정, 동기를 반영한 Why 문장을 생성해주세요.\n     Why 문장은 간결하고 명확하게, 그리고 사용자의 고유한 특성을 담아야 합니다.\n     `\n     \n     // OpenAI API 호출\n     const completion = await openai.chat.completions.create({\n       model: \"gpt-4o\",\n       messages: [\n         { role: \"system\", content: \"당신은 사용자의 Why 문장을 생성하는 전문가입니다.\" },\n         { role: \"user\", content: prompt }\n       ],\n       temperature: 0.7,\n     })\n     \n     return completion.choices[0].message.content\n   }\n   ```\n2. Why 문장 생성 API 엔드포인트:\n   ```typescript\n   // app/api/why-generation/route.ts\n   import { NextRequest, NextResponse } from 'next/server'\n   import { generateWhyStatement } from '@/lib/why-generation'\n   import { addMessage } from '@/lib/messages'\n   import { updateSessionStatus } from '@/lib/sessions'\n   \n   export async function POST(req: NextRequest) {\n     try {\n       const { sessionId } = await req.json()\n       \n       // Why 문장 생성\n       const whyStatement = await generateWhyStatement(sessionId)\n       \n       // 생성된 Why 문장을 메시지로 저장\n       await addMessage(sessionId, 'assistant', whyStatement, 'main')\n       \n       // 세션 상태 업데이트\n       await updateSessionStatus(sessionId, 'completed')\n       \n       return NextResponse.json({ whyStatement })\n     } catch (error) {\n       console.error('Why generation error:', error)\n       return NextResponse.json({ error: 'Failed to generate Why statement' }, { status: 500 })\n     }\n   }\n   ```\n3. Why 문장 표시 컴포넌트:\n   ```typescript\n   // components/consultation/WhyStatement.tsx\n   interface WhyStatementProps {\n     statement: string\n   }\n   \n   export function WhyStatement({ statement }: WhyStatementProps) {\n     return (\n       <div className=\"my-8 p-6 bg-gradient-to-r from-indigo-500 to-purple-600 rounded-lg text-white\">\n         <h2 className=\"text-xl font-bold mb-4 text-center\">당신의 Why</h2>\n         <p className=\"text-2xl font-medium text-center\">\"{statement}\"</p>\n       </div>\n     )\n   }\n   ```",
        "testStrategy": "1. 다양한 사용자 응답으로 Why 문장 생성 테스트\n2. 형식 준수 여부 검증\n3. 생성된 Why 문장의 품질 평가\n4. 오류 처리 및 예외 상황 테스트\n5. API 응답 시간 및 성능 테스트",
        "priority": "high",
        "dependencies": [
          8,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "상담 히스토리 관리 시스템 구현",
        "description": "사용자별 상담 히스토리 저장, 조회, 관리 기능 구현",
        "details": "1. 히스토리 조회 API 구현:\n   ```typescript\n   // lib/history.ts\n   import { createSupabaseClient } from './supabase'\n   \n   export async function getUserConsultationHistory(userId: string) {\n     const supabase = createSupabaseClient()\n     \n     const { data, error } = await supabase\n       .from('sessions')\n       .select(`\n         id,\n         created_at,\n         updated_at,\n         status,\n         title,\n         messages!inner (id, content, role, character_type, created_at)\n       `)\n       .eq('user_id', userId)\n       .order('updated_at', { ascending: false })\n     \n     if (error) throw error\n     \n     // 각 세션의 마지막 메시지와 Why 문장 찾기\n     return data.map(session => {\n       const messages = session.messages || []\n       const lastMessage = messages.sort((a, b) => \n         new Date(b.created_at).getTime() - new Date(a.created_at).getTime()\n       )[0]\n       \n       // Why 문장 찾기 (마지막 assistant 메시지이면서 main 캐릭터인 경우)\n       const whyStatement = messages\n         .filter(m => m.role === 'assistant' && m.character_type === 'main')\n         .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())\n         [0]?.content || null\n       \n       return {\n         ...session,\n         lastMessage: lastMessage?.content || null,\n         whyStatement\n       }\n     })\n   }\n   \n   export async function getConsultationDetail(sessionId: string) {\n     const supabase = createSupabaseClient()\n     \n     const { data: session, error: sessionError } = await supabase\n       .from('sessions')\n       .select('*')\n       .eq('id', sessionId)\n       .single()\n     \n     if (sessionError) throw sessionError\n     \n     const { data: messages, error: messagesError } = await supabase\n       .from('messages')\n       .select('*')\n       .eq('session_id', sessionId)\n       .order('created_at', { ascending: true })\n     \n     if (messagesError) throw messagesError\n     \n     return {\n       ...session,\n       messages: messages || []\n     }\n   }\n   ```\n2. 히스토리 목록 컴포넌트:\n   ```typescript\n   // components/history/ConsultationHistoryList.tsx\n   interface ConsultationHistoryProps {\n     history: Array<{\n       id: string\n       title: string\n       created_at: string\n       status: string\n       lastMessage: string | null\n       whyStatement: string | null\n     }>\n     onSelectSession: (sessionId: string) => void\n   }\n   \n   export function ConsultationHistoryList({ history, onSelectSession }: ConsultationHistoryProps) {\n     return (\n       <div className=\"space-y-4\">\n         <h2 className=\"text-xl font-semibold\">상담 히스토리</h2>\n         \n         {history.length === 0 ? (\n           <p className=\"text-gray-500\">아직 상담 기록이 없습니다.</p>\n         ) : (\n           <div className=\"space-y-3\">\n             {history.map(session => (\n               <div \n                 key={session.id}\n                 onClick={() => onSelectSession(session.id)}\n                 className=\"p-4 border rounded-lg hover:bg-gray-50 cursor-pointer transition-colors\"\n               >\n                 <div className=\"flex justify-between items-start mb-2\">\n                   <h3 className=\"font-medium\">{session.title || '제목 없음'}</h3>\n                   <span className=\"text-xs px-2 py-1 rounded-full bg-gray-100\">\n                     {session.status === 'completed' ? '완료' : '진행 중'}\n                   </span>\n                 </div>\n                 \n                 <p className=\"text-sm text-gray-500 mb-2\">\n                   {new Date(session.created_at).toLocaleDateString()}\n                 </p>\n                 \n                 {session.whyStatement && (\n                   <div className=\"mt-2 p-2 bg-indigo-50 rounded text-sm\">\n                     <span className=\"font-medium\">Why: </span>\n                     {session.whyStatement}\n                   </div>\n                 )}\n                 \n                 {session.lastMessage && !session.whyStatement && (\n                   <p className=\"mt-2 text-sm text-gray-700 truncate\">\n                     {session.lastMessage}\n                   </p>\n                 )}\n               </div>\n             ))}\n           </div>\n         )}\n       </div>\n     )\n   }\n   ```\n3. 상담 상세 보기 페이지 구현",
        "testStrategy": "1. 히스토리 목록 조회 테스트\n2. 상담 상세 정보 조회 테스트\n3. 히스토리 필터링 및 정렬 테스트\n4. 페이지네이션 테스트 (많은 상담 기록 처리)\n5. 상담 삭제 및 수정 기능 테스트",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "반응형 UI 및 모바일 최적화",
        "description": "모바일과 데스크톱 환경 모두에 최적화된 반응형 UI 구현",
        "details": "1. 반응형 레이아웃 구현:\n   ```typescript\n   // components/layout/ResponsiveLayout.tsx\n   interface ResponsiveLayoutProps {\n     children: React.ReactNode\n   }\n   \n   export function ResponsiveLayout({ children }: ResponsiveLayoutProps) {\n     return (\n       <div className=\"min-h-screen bg-gradient-to-b from-gray-50 to-gray-100\">\n         <div className=\"max-w-4xl mx-auto px-4 sm:px-6 lg:px-8\">\n           {children}\n         </div>\n       </div>\n     )\n   }\n   ```\n2. 모바일 친화적 폰트 크기 및 패딩 설정:\n   ```css\n   /* styles/globals.css */\n   @layer base {\n     html {\n       font-size: 16px;\n     }\n     \n     @media (max-width: 640px) {\n       html {\n         font-size: 14px;\n       }\n     }\n     \n     body {\n       @apply text-gray-900 bg-gray-50;\n     }\n     \n     h1 {\n       @apply text-2xl sm:text-3xl font-bold;\n     }\n     \n     h2 {\n       @apply text-xl sm:text-2xl font-semibold;\n     }\n     \n     /* 기타 타이포그래피 설정 */\n   }\n   ```\n3. 모바일 터치 인터랙션 최적화:\n   ```typescript\n   // components/common/TouchFriendlyButton.tsx\n   interface TouchFriendlyButtonProps {\n     onClick: () => void\n     children: React.ReactNode\n     className?: string\n     disabled?: boolean\n   }\n   \n   export function TouchFriendlyButton({ \n     onClick, \n     children, \n     className = '', \n     disabled = false \n   }: TouchFriendlyButtonProps) {\n     return (\n       <button\n         onClick={onClick}\n         disabled={disabled}\n         className={`py-3 px-4 rounded-lg active:opacity-80 ${disabled ? 'opacity-50' : ''} ${className}`}\n         style={{ WebkitTapHighlightColor: 'transparent' }}\n       >\n         {children}\n       </button>\n     )\n   }\n   ```\n4. 모바일 키보드 처리:\n   ```typescript\n   // hooks/useKeyboardAware.ts\n   import { useState, useEffect } from 'react'\n   \n   export function useKeyboardAware() {\n     const [isKeyboardVisible, setIsKeyboardVisible] = useState(false)\n     \n     useEffect(() => {\n       const handleResize = () => {\n         // 모바일에서 키보드가 올라오면 viewport 높이가 줄어듦\n         const viewportHeight = window.visualViewport?.height || window.innerHeight\n         const windowHeight = window.innerHeight\n         \n         // 키보드가 올라왔다고 판단할 수 있는 임계값 (예: 30%)\n         setIsKeyboardVisible(viewportHeight < windowHeight * 0.7)\n       }\n       \n       window.visualViewport?.addEventListener('resize', handleResize)\n       return () => window.visualViewport?.removeEventListener('resize', handleResize)\n     }, [])\n     \n     return { isKeyboardVisible }\n   }\n   ```\n5. 미디어 쿼리를 활용한 레이아웃 조정:\n   ```typescript\n   // hooks/useMediaQuery.ts\n   import { useState, useEffect } from 'react'\n   \n   export function useMediaQuery(query: string) {\n     const [matches, setMatches] = useState(false)\n     \n     useEffect(() => {\n       const media = window.matchMedia(query)\n       setMatches(media.matches)\n       \n       const listener = (e: MediaQueryListEvent) => setMatches(e.matches)\n       media.addEventListener('change', listener)\n       \n       return () => media.removeEventListener('change', listener)\n     }, [query])\n     \n     return matches\n   }\n   ```",
        "testStrategy": "1. 다양한 화면 크기에서의 레이아웃 테스트\n2. 모바일 기기에서의 터치 인터랙션 테스트\n3. 키보드 표시/숨김에 따른 UI 조정 테스트\n4. 다양한 모바일 브라우저 호환성 테스트\n5. 접근성 테스트 (글꼴 크기, 색상 대비 등)",
        "priority": "medium",
        "dependencies": [
          4,
          10
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "성능 최적화 및 로딩 상태 관리",
        "description": "애플리케이션 성능 최적화 및 사용자 경험을 위한 로딩 상태 관리 구현",
        "details": "1. 이미지 최적화:\n   ```typescript\n   // components/common/OptimizedImage.tsx\n   import Image from 'next/image'\n   \n   interface OptimizedImageProps {\n     src: string\n     alt: string\n     width?: number\n     height?: number\n     className?: string\n   }\n   \n   export function OptimizedImage({ \n     src, \n     alt, \n     width, \n     height, \n     className = '' \n   }: OptimizedImageProps) {\n     return (\n       <div className={`relative ${className}`}>\n         <Image\n           src={src}\n           alt={alt}\n           width={width}\n           height={height}\n           loading=\"lazy\"\n           className=\"object-cover\"\n         />\n       </div>\n     )\n   }\n   ```\n2. 로딩 상태 컴포넌트:\n   ```typescript\n   // components/common/LoadingSpinner.tsx\n   interface LoadingSpinnerProps {\n     size?: 'small' | 'medium' | 'large'\n     color?: string\n   }\n   \n   export function LoadingSpinner({ \n     size = 'medium', \n     color = '#6366f1' \n   }: LoadingSpinnerProps) {\n     const sizeClass = {\n       small: 'w-4 h-4',\n       medium: 'w-8 h-8',\n       large: 'w-12 h-12'\n     }\n     \n     return (\n       <div className=\"flex justify-center items-center\">\n         <div \n           className={`${sizeClass[size]} rounded-full border-2 border-t-transparent animate-spin`}\n           style={{ borderColor: `${color}40`, borderTopColor: color }}\n         />\n       </div>\n     )\n   }\n   ```\n3. 컴포넌트 지연 로딩:\n   ```typescript\n   // app/page.tsx\n   import dynamic from 'next/dynamic'\n   \n   // 지연 로딩할 컴포넌트\n   const DynamicConsultationHistory = dynamic(\n     () => import('@/components/history/ConsultationHistoryList').then(mod => mod.ConsultationHistoryList),\n     { \n       loading: () => <LoadingSpinner size=\"large\" />,\n       ssr: false\n     }\n   )\n   ```\n4. 데이터 캐싱 및 재검증:\n   ```typescript\n   // lib/cache.ts\n   import { cache } from 'react'\n   import { getUserConsultationHistory } from './history'\n   \n   export const getCachedUserHistory = cache(async (userId: string) => {\n     return await getUserConsultationHistory(userId)\n   })\n   ```\n5. 스켈레톤 로딩 UI:\n   ```typescript\n   // components/common/SkeletonLoader.tsx\n   interface SkeletonLoaderProps {\n     count?: number\n     type: 'card' | 'text' | 'circle'\n     className?: string\n   }\n   \n   export function SkeletonLoader({ \n     count = 1, \n     type, \n     className = '' \n   }: SkeletonLoaderProps) {\n     const items = Array.from({ length: count }, (_, i) => i)\n     \n     const getTypeClass = () => {\n       switch (type) {\n         case 'card':\n           return 'h-32 rounded-lg'\n         case 'text':\n           return 'h-4 rounded'\n         case 'circle':\n           return 'h-10 w-10 rounded-full'\n       }\n     }\n     \n     return (\n       <div className=\"space-y-3\">\n         {items.map(i => (\n           <div \n             key={i}\n             className={`bg-gray-200 animate-pulse ${getTypeClass()} ${className}`}\n           />\n         ))}\n       </div>\n     )\n   }\n   ```",
        "testStrategy": "1. 페이지 로드 시간 측정 및 최적화\n2. 이미지 로딩 성능 테스트\n3. 로딩 상태 UI 테스트\n4. 데이터 캐싱 효과 검증\n5. 네트워크 지연 상황에서의 UX 테스트\n6. Lighthouse 성능 점수 측정",
        "priority": "medium",
        "dependencies": [
          10,
          13
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "배포 및 환경 설정",
        "description": "Vercel을 통한 배포 및 개발/프로덕션 환경 설정",
        "details": "1. 환경 변수 설정:\n   ```\n   # .env.development\n   NEXT_PUBLIC_SUPABASE_URL=your_development_supabase_url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your_development_anon_key\n   SUPABASE_SERVICE_ROLE_KEY=your_development_service_key\n   OPENAI_API_KEY=your_development_openai_key\n   \n   # .env.production\n   NEXT_PUBLIC_SUPABASE_URL=your_production_supabase_url\n   NEXT_PUBLIC_SUPABASE_ANON_KEY=your_production_anon_key\n   SUPABASE_SERVICE_ROLE_KEY=your_production_service_key\n   OPENAI_API_KEY=your_production_openai_key\n   ```\n2. Vercel 배포 설정 (vercel.json):\n   ```json\n   {\n     \"framework\": \"nextjs\",\n     \"buildCommand\": \"next build\",\n     \"devCommand\": \"next dev\",\n     \"installCommand\": \"npm install\",\n     \"outputDirectory\": \".next\",\n     \"regions\": [\"icn1\"],\n     \"headers\": [\n       {\n         \"source\": \"/(.*)\",\n         \"headers\": [\n           {\n             \"key\": \"X-Content-Type-Options\",\n             \"value\": \"nosniff\"\n           },\n           {\n             \"key\": \"X-Frame-Options\",\n             \"value\": \"DENY\"\n           },\n           {\n             \"key\": \"X-XSS-Protection\",\n             \"value\": \"1; mode=block\"\n           }\n         ]\n       }\n     ]\n   }\n   ```\n3. GitHub Actions CI/CD 설정 (.github/workflows/ci.yml):\n   ```yaml\n   name: CI/CD Pipeline\n   \n   on:\n     push:\n       branches: [main]\n     pull_request:\n       branches: [main]\n   \n   jobs:\n     build-and-test:\n       runs-on: ubuntu-latest\n       \n       steps:\n         - uses: actions/checkout@v3\n         \n         - name: Setup Node.js\n           uses: actions/setup-node@v3\n           with:\n             node-version: '18'\n             cache: 'npm'\n         \n         - name: Install dependencies\n           run: npm ci\n         \n         - name: Lint\n           run: npm run lint\n         \n         - name: Type check\n           run: npm run type-check\n         \n         - name: Build\n           run: npm run build\n   ```\n4. 배포 스크립트 (package.json):\n   ```json\n   {\n     \"scripts\": {\n       \"dev\": \"next dev\",\n       \"build\": \"next build\",\n       \"start\": \"next start\",\n       \"lint\": \"next lint\",\n       \"type-check\": \"tsc --noEmit\",\n       \"deploy:staging\": \"vercel\",\n       \"deploy:production\": \"vercel --prod\"\n     }\n   }\n   ```\n5. 에러 모니터링 설정 (Sentry 등)",
        "testStrategy": "1. 개발/프로덕션 환경 변수 분리 테스트\n2. Vercel 배포 테스트\n3. CI/CD 파이프라인 테스트\n4. 보안 헤더 설정 확인\n5. 배포 후 성능 모니터링\n6. 에러 로깅 및 모니터링 테스트",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "프로젝트 구조 문서화 및 파일 관계도 작성",
        "description": "프로젝트의 전체 구조를 문서화하고 파일 간 관계도를 작성하여 토큰 효율성을 위한 참고 자료 생성",
        "details": "1. 프로젝트 디렉토리 구조 문서화:\n   ```bash\n   # 프로젝트 루트에서 실행\n   find . -type f -not -path \"*/node_modules/*\" -not -path \"*/\\.*\" | sort > project_structure.txt\n   ```\n\n2. 주요 디렉토리 및 파일 설명 문서 작성:\n   ```markdown\n   # 프로젝트 구조 문서\n   \n   ## 디렉토리 구조\n   - `/app`: Next.js 라우팅 및 페이지 컴포넌트\n   - `/components`: 재사용 가능한 UI 컴포넌트\n   - `/lib`: 유틸리티 함수 및 API 클라이언트\n   - `/public`: 정적 에셋 파일\n   - `/styles`: 글로벌 스타일 및 테마 설정\n   \n   ## 주요 파일 설명\n   - `app/layout.tsx`: 전역 레이아웃 컴포넌트\n   - `lib/supabase.ts`: Supabase 클라이언트 설정\n   - `lib/openai.ts`: OpenAI API 연동 설정\n   ```\n\n3. 컴포넌트 의존성 관계도 작성:\n   ```typescript\n   // docs/component-relationships.ts\n   interface ComponentRelationship {\n     component: string;\n     dependencies: string[];\n     description: string;\n   }\n   \n   export const componentRelationships: ComponentRelationship[] = [\n     {\n       component: 'ChatInterface',\n       dependencies: ['MessageList', 'InputForm', 'CharacterSelection'],\n       description: '상담 인터페이스 메인 컴포넌트'\n     },\n     {\n       component: 'MessageList',\n       dependencies: ['Message', 'LoadingIndicator'],\n       description: '메시지 목록 표시 컴포넌트'\n     },\n     // 추가 컴포넌트 관계 정의\n   ];\n   ```\n\n4. API 및 데이터 흐름 다이어그램 작성:\n   ```mermaid\n   graph TD\n     A[사용자 입력] --> B[InputForm]\n     B --> C[API 요청 처리]\n     C --> D[OpenAI API]\n     D --> E[응답 처리]\n     E --> F[메시지 저장]\n     F --> G[Supabase DB]\n     E --> H[UI 업데이트]\n   ```\n\n5. 토큰 효율성을 위한 프롬프트 참조 문서 작성:\n   ```markdown\n   # 프롬프트 최적화 가이드\n   \n   ## 토큰 효율성 향상 방법\n   1. 핵심 정보만 포함하기\n   2. 중복 설명 제거하기\n   3. 간결한 지시문 사용하기\n   \n   ## 주요 프롬프트 템플릿\n   - 상담 시작 프롬프트: [템플릿 설명]\n   - Why 문장 생성 프롬프트: [템플릿 설명]\n   ```\n\n6. 문서화 자동화 스크립트 작성:\n   ```typescript\n   // scripts/generate-docs.ts\n   import fs from 'fs';\n   import path from 'path';\n   \n   async function generateProjectStructure() {\n     // 구현 로직\n   }\n   \n   async function generateComponentRelationships() {\n     // 구현 로직\n   }\n   \n   async function main() {\n     await generateProjectStructure();\n     await generateComponentRelationships();\n     console.log('Documentation generated successfully');\n   }\n   \n   main().catch(console.error);\n   ```",
        "testStrategy": "1. 프로젝트 구조 문서 검증:\n   - 모든 주요 디렉토리와 파일이 문서에 포함되었는지 확인\n   - 누락된 중요 컴포넌트나 모듈이 없는지 검토\n\n2. 컴포넌트 관계도 정확성 검증:\n   - 각 컴포넌트의 import 문을 분석하여 실제 의존성과 문서화된 의존성이 일치하는지 확인\n   - 누락된 의존성이 있는지 검토\n\n3. API 및 데이터 흐름 다이어그램 검증:\n   - 실제 코드 흐름과 다이어그램이 일치하는지 확인\n   - 주요 데이터 처리 경로가 모두 포함되었는지 검토\n\n4. 토큰 효율성 문서 유용성 평가:\n   - 개발자 피드백을 통해 문서의 실용성 평가\n   - 실제 프롬프트 최적화에 도움이 되는지 검증\n\n5. 문서 가독성 및 접근성 테스트:\n   - 팀원들이 문서를 쉽게 찾고 이해할 수 있는지 확인\n   - 문서 포맷과 구조의 일관성 검토\n\n6. 자동화 스크립트 테스트:\n   - 문서 생성 스크립트가 오류 없이 실행되는지 확인\n   - 생성된 문서가 최신 코드베이스를 정확히 반영하는지 검증",
        "status": "done",
        "dependencies": [
          1,
          2,
          3,
          4,
          10,
          15
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Fix Chat Bubble Newline Rendering and Typography Consistency",
        "description": "Fix chat bubble rendering to preserve line breaks from both user and GPT responses, and unify letter-spacing between onboarding typing animation and final text state.",
        "details": "1. Chat Bubble Newline Preservation:\n   ```typescript\n   // components/chat/ChatBubble.tsx\n   import React from 'react';\n   \n   interface ChatBubbleProps {\n     content: string;\n     isUser: boolean;\n     // other props...\n   }\n   \n   export function ChatBubble({ content, isUser }: ChatBubbleProps) {\n     // Transform newlines to proper HTML line breaks\n     const formattedContent = content.split('\\n').map((line, index) => (\n       <React.Fragment key={index}>\n         {line}\n         {index < content.split('\\n').length - 1 && <br />}\n       </React.Fragment>\n     ));\n     \n     return (\n       <div className={`chat-bubble ${isUser ? 'user-bubble' : 'gpt-bubble'}`}>\n         <div className=\"bubble-content whitespace-pre-wrap\">\n           {formattedContent}\n         </div>\n       </div>\n     );\n   }\n   ```\n\n2. Typography Consistency Fix:\n   ```css\n   /* styles/typography.css */\n   .typing-animation, .final-text {\n     letter-spacing: 0.02em; /* Consistent letter spacing */\n     line-height: 1.5;\n     font-family: 'Your-Font-Family', sans-serif;\n   }\n   ```\n\n3. Update Onboarding Component:\n   ```typescript\n   // components/onboarding/TypingAnimation.tsx\n   export function TypingAnimation({ text, isComplete }: TypingAnimationProps) {\n     return (\n       <div className={`${isComplete ? 'final-text' : 'typing-animation'}`}>\n         {/* Animation logic */}\n         {text}\n       </div>\n     );\n   }\n   ```\n\n4. Ensure CSS classes are properly applied in both contexts:\n   - Review all components that display chat messages\n   - Ensure consistent styling between typing animation and static text\n   - Apply the same whitespace handling to both contexts\n\n5. Update any message rendering components to use the improved ChatBubble component:\n   ```typescript\n   // components/chat/MessageList.tsx\n   import { ChatBubble } from './ChatBubble';\n   \n   export function MessageList({ messages }) {\n     return (\n       <div className=\"message-container\">\n         {messages.map((message) => (\n           <ChatBubble\n             key={message.id}\n             content={message.content}\n             isUser={message.role === 'user'}\n             // other props...\n           />\n         ))}\n       </div>\n     );\n   }\n   ```",
        "testStrategy": "1. Newline Preservation Testing:\n   - Create test messages with multiple line breaks in different patterns\n   - Verify that user messages correctly display line breaks as entered\n   - Verify that GPT responses correctly display line breaks as received\n   - Test with edge cases: consecutive line breaks, line breaks at start/end of messages\n\n2. Typography Consistency Testing:\n   - Compare letter-spacing in onboarding typing animation and final text state\n   - Verify consistent appearance across different screen sizes and browsers\n   - Take screenshots before and after the fix to document the improvement\n   - Use browser dev tools to confirm CSS properties are identical\n\n3. Visual Regression Testing:\n   - Capture screenshots of chat bubbles before and after changes\n   - Compare rendering in different browsers (Chrome, Firefox, Safari)\n   - Test on both desktop and mobile viewports\n\n4. User Experience Testing:\n   - Verify that long messages with multiple paragraphs are readable\n   - Ensure code blocks and formatted text maintain proper spacing\n   - Test with real conversations to ensure natural reading flow\n\n5. Performance Testing:\n   - Measure any impact on rendering performance with large messages\n   - Ensure smooth scrolling with many messages containing line breaks\n\n6. Deployment Verification:\n   - After deployment, verify fixes in production environment\n   - Test with actual user conversations to confirm improvements",
        "status": "pending",
        "dependencies": [
          10,
          13,
          14
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Update ChatBubble component to properly preserve newlines",
            "description": "Modify the ChatBubble component to correctly render newlines in both user and GPT messages using CSS and React Fragment approach.",
            "dependencies": [],
            "details": "1. Update the ChatBubble.tsx component to ensure newlines are preserved:\n- Modify the whitespace handling in the bubble-content class to use whitespace-pre-wrap\n- Ensure the formattedContent logic correctly splits and rejoins content with line breaks\n- Test with various message formats including consecutive newlines\n2. Apply the same formatting logic to both user and GPT bubbles\n3. Verify that the implementation works with dynamic content loading",
            "status": "pending",
            "testStrategy": "Create test messages with various newline patterns (single, multiple consecutive, mixed with other content) and verify visual rendering in both user and GPT bubbles. Test with actual API responses to ensure compatibility."
          },
          {
            "id": 2,
            "title": "Implement special handling for [ANSWER_READY] multiline blocks",
            "description": "Add specific rendering logic for GPT responses containing [ANSWER_READY] tags with multiline content to ensure proper formatting.",
            "dependencies": [
              "17.1"
            ],
            "details": "1. Identify the pattern used for [ANSWER_READY] blocks in GPT responses\n2. Add a special case in the ChatBubble component to detect and handle these blocks:\n```typescript\n// Add to ChatBubble.tsx\nconst processAnswerReadyBlocks = (content: string) => {\n  // Check if content contains [ANSWER_READY] tag\n  if (content.includes('[ANSWER_READY]')) {\n    // Extract and format the block appropriately\n    // Return properly formatted content\n  }\n  return content;\n};\n```\n3. Apply this processing before the newline formatting logic\n4. Ensure the blocks maintain their structure and formatting",
            "status": "pending",
            "testStrategy": "Create test cases with sample [ANSWER_READY] blocks containing various formatting patterns. Verify that the blocks render correctly with proper newlines and spacing. Test edge cases like nested blocks or partial tags."
          },
          {
            "id": 3,
            "title": "Unify typography between typing animation and final text state",
            "description": "Standardize letter-spacing, line-height, and font properties between the typing animation and final text state in the onboarding component.",
            "dependencies": [],
            "details": "1. Create a shared typography CSS class that can be applied to both states:\n```css\n/* styles/typography.css */\n.shared-typography {\n  letter-spacing: 0.02em;\n  line-height: 1.5;\n  font-family: 'Your-Font-Family', sans-serif;\n}\n```\n2. Update the TypingAnimation component to use this shared class:\n```typescript\n// components/onboarding/TypingAnimation.tsx\nexport function TypingAnimation({ text, isComplete }: TypingAnimationProps) {\n  return (\n    <div className={`shared-typography ${isComplete ? 'final-text' : 'typing-animation'}`}>\n      {/* Animation logic */}\n      {text}\n    </div>\n  );\n}\n```\n3. Ensure any specific styling needed for animation doesn't affect the typography consistency",
            "status": "pending",
            "testStrategy": "Compare the rendered output of the typing animation and final text state side by side. Measure letter-spacing and line-height to ensure they match exactly. Test across different viewport sizes and with various text content lengths."
          },
          {
            "id": 4,
            "title": "Update all message rendering components and add regression tests",
            "description": "Ensure all components that display chat messages use the improved ChatBubble component and create regression tests to prevent future issues.",
            "dependencies": [
              "17.1",
              "17.2",
              "17.3"
            ],
            "details": "1. Identify all components that render chat messages (MessageList, CharacterMessage, UserMessage, etc.)\n2. Update each component to use the improved ChatBubble component:\n```typescript\n// For each message rendering component\nimport { ChatBubble } from './ChatBubble';\n\n// Replace direct message rendering with ChatBubble\n<ChatBubble\n  content={message.content}\n  isUser={message.role === 'user'}\n  // Pass any additional props needed\n/>\n```\n3. Create a comprehensive test suite that covers various message formats and edge cases\n4. Add manual testing steps to the QA process to verify visual consistency",
            "status": "pending",
            "testStrategy": "1. Create automated tests for newline rendering in different contexts\n2. Test with real user input patterns and API responses\n3. Visual regression testing to compare before/after screenshots\n4. Create a test matrix covering different message types, lengths, and formatting\n5. Document manual verification steps for QA team"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-18T05:37:51.615Z",
      "updated": "2025-08-22T11:38:51.621Z",
      "description": "Tasks for master context"
    }
  },
  "design-refresh": {
    "tasks": [
      {
        "id": 1,
        "title": "Extract and Organize Design Assets",
        "description": "Extract all design assets from the design-ref zip file and organize them into appropriate project folders with consistent naming conventions.",
        "details": "1. Download and extract the design-ref.zip file to a temporary location\n2. Identify all assets in the extracted files (fonts, images, SVGs, etc.)\n3. Create the following directory structure if it doesn't exist:\n   - public/ (for static assets served directly)\n   - src/styles/ (for CSS, SCSS, and font files)\n   - src/assets/ (for images, SVGs, and other media used in the application)\n4. Sort assets by type:\n   - Fonts (.ttf, .woff, .woff2, etc.) → src/styles/fonts/\n   - Images (.jpg, .png, .webp, etc.) → src/assets/images/\n   - SVGs → src/assets/icons/ or src/assets/svg/\n   - Logos and brand assets → public/\n5. Implement a consistent naming convention:\n   - Use kebab-case for all filenames (e.g., hero-image.png, open-sans-regular.woff)\n   - Group related assets with prefixes (e.g., icon-home.svg, icon-profile.svg)\n   - Include size/resolution in image names if multiple versions exist (e.g., logo-small.png, logo-large.png)\n6. Create an assets inventory document (assets.md) listing all extracted assets and their new locations\n7. Update any existing references to these assets in the codebase if applicable",
        "testStrategy": "1. Verify all files from design-ref.zip have been extracted and properly categorized\n2. Confirm directory structure is correct with appropriate subdirectories\n3. Check that all assets follow the established naming convention\n4. Validate that no duplicate assets exist across different folders\n5. Ensure font files are properly organized and accessible for web use\n6. Verify SVGs are properly formatted and optimized for web use\n7. Test loading several assets from each category to ensure paths are correct\n8. Review the assets inventory document for completeness and accuracy\n9. If applicable, check that existing code references to assets have been updated\n10. Have another team member review the organization for clarity and consistency",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Define Design Tokens Using CSS Variables",
        "description": "Create a comprehensive set of design tokens using CSS variables that support both light and dark themes, centralizing them in styles/tokens.css and integrating them into globals.css.",
        "details": "1. Create a new file `src/styles/tokens.css` to house all design tokens\n2. Define the following token categories using CSS variables:\n   - Colors: Define base colors, semantic colors (primary, secondary, accent), and functional colors (success, warning, error)\n   - Typography: Create a type scale with variables for font-family, font-size, line-height, font-weight\n   - Spacing: Establish a consistent spacing scale (4px, 8px, 16px, etc.)\n   - Border radii: Define variables for different levels of corner rounding\n   - Shadows: Create elevation levels with corresponding shadow values\n\n3. Structure the tokens file with clear organization:\n```css\n:root {\n  /* Base colors */\n  --color-white: #ffffff;\n  --color-black: #000000;\n  \n  /* Brand colors */\n  --color-primary-50: #e6f1fe;\n  --color-primary-100: #c0dcfd;\n  /* ... other color variations ... */\n  \n  /* Typography */\n  --font-family-base: 'Inter', system-ui, sans-serif;\n  --font-size-xs: 0.75rem;\n  --font-size-sm: 0.875rem;\n  /* ... other typography tokens ... */\n  \n  /* Spacing */\n  --space-1: 0.25rem;\n  --space-2: 0.5rem;\n  /* ... other spacing tokens ... */\n  \n  /* Border radius */\n  --radius-sm: 0.125rem;\n  --radius-md: 0.25rem;\n  /* ... other radius tokens ... */\n  \n  /* Shadows */\n  --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);\n  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\n  /* ... other shadow tokens ... */\n}\n\n/* Dark theme overrides */\n@media (prefers-color-scheme: dark) {\n  :root {\n    --color-white: #000000;\n    --color-black: #ffffff;\n    /* ... other dark theme overrides ... */\n  }\n}\n\n/* Class-based theme switching */\n.dark-theme {\n  --color-white: #000000;\n  --color-black: #ffffff;\n  /* ... other dark theme overrides ... */\n}\n```\n\n4. Extract color values, typography settings, and other design tokens from the design assets provided in Task #1\n5. Implement both automatic theme switching (using `prefers-color-scheme` media query) and manual theme switching (using the `.dark-theme` class)\n6. Import the tokens file into `src/styles/globals.css` with:\n```css\n@import './tokens.css';\n```\n7. Update any existing styles in globals.css to use the new token variables instead of hardcoded values",
        "testStrategy": "1. Verify that all design tokens are properly defined in tokens.css with appropriate values extracted from design assets\n2. Confirm that tokens.css is correctly imported into globals.css\n3. Test the dark mode implementation by:\n   - Using browser dev tools to toggle the prefers-color-scheme media feature\n   - Adding and removing the .dark-theme class to the root element\n4. Validate that all token categories (colors, typography, spacing, radii, shadows) are properly defined and have appropriate values\n5. Check for any hardcoded values in globals.css that should be replaced with token variables\n6. Verify that the tokens follow a consistent naming convention\n7. Test the appearance of the application in both light and dark modes to ensure proper contrast and readability\n8. Validate that the tokens are accessible throughout the application by applying them to test elements\n9. Review the implementation with the design team to ensure the tokens accurately reflect the intended design system",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Typography System with Font Loading",
        "description": "Implement font loading from design-ref assets, set up @font-face declarations in styles, and apply a consistent type ramp to headings, body text, and monospace elements.",
        "details": "1. Review the font files extracted from design-ref in the src/styles/fonts/ directory\n2. Create a new file `src/styles/typography.css` to house all font-related styles\n3. Implement @font-face declarations for each required font:\n   ```css\n   @font-face {\n     font-family: 'PrimaryFont';\n     src: url('/fonts/primary-regular.woff2') format('woff2'),\n          url('/fonts/primary-regular.woff') format('woff');\n     font-weight: 400;\n     font-style: normal;\n     font-display: swap;\n   }\n   /* Repeat for each font weight/style variation */\n   ```\n4. Consider performance optimization:\n   - Use woff2 format as primary with woff as fallback\n   - Implement font-display: swap to prevent FOIT (Flash of Invisible Text)\n   - Consider preloading critical fonts in the document head\n5. Define a comprehensive type ramp in typography.css using the typography tokens from tokens.css:\n   ```css\n   /* Heading styles */\n   h1 {\n     font-family: var(--font-family-heading);\n     font-size: var(--font-size-xxl);\n     line-height: var(--line-height-tight);\n     font-weight: var(--font-weight-bold);\n   }\n   /* Continue for h2-h6, body text, and monospace elements */\n   ```\n6. Create utility classes for common typography needs:\n   ```css\n   .text-body-large {\n     font-family: var(--font-family-body);\n     font-size: var(--font-size-lg);\n     line-height: var(--line-height-normal);\n   }\n   /* Additional utility classes */\n   ```\n7. Import typography.css into globals.css after tokens.css to ensure proper cascade\n8. Document the typography system in a README.md file or comments for developer reference",
        "testStrategy": "1. Verify all font files are correctly referenced in @font-face declarations with proper paths\n2. Test font loading in different browsers to ensure cross-browser compatibility\n3. Validate that the typography.css file is properly imported into globals.css\n4. Create a typography test page that displays:\n   - All heading levels (h1-h6) with applied styles\n   - Body text in various sizes\n   - Monospace text elements\n5. Inspect the rendered typography using browser dev tools to confirm:\n   - Correct font families are applied to each text element\n   - Font sizes match the design specifications\n   - Line heights are applied correctly\n6. Test font loading performance:\n   - Use browser network tab to verify efficient loading\n   - Check for any FOIT/FOUT (Flash of Unstyled Text) issues\n   - Validate font-display: swap is working as expected\n7. Verify responsive behavior of typography at different viewport sizes\n8. Ensure all typography follows the design tokens defined in Task 2",
        "status": "pending",
        "dependencies": [
          1,
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Update Base and Global Styles",
        "description": "Update HTML, body, link, selection, and scrollbar styles to match design-ref specifications, ensuring mobile-safe defaults are implemented.",
        "details": "1. Create a new file `src/styles/base.css` to contain all base element styles\n2. Implement global styles for the following elements:\n   ```css\n   html {\n     /* Set base font size for rem calculations */\n     font-size: 16px;\n     /* Apply smooth scrolling behavior */\n     scroll-behavior: smooth;\n     /* Ensure proper text sizing across devices */\n     -webkit-text-size-adjust: 100%;\n   }\n   \n   body {\n     /* Apply primary font family from typography system */\n     font-family: var(--font-primary);\n     /* Use token values for text color and background */\n     color: var(--color-text);\n     background-color: var(--color-background);\n     /* Reset margins */\n     margin: 0;\n     /* Set line height from typography tokens */\n     line-height: var(--line-height-body);\n   }\n   \n   a {\n     /* Apply link styling using color tokens */\n     color: var(--color-primary);\n     text-decoration: none;\n     transition: color 0.2s ease;\n   }\n   \n   a:hover, a:focus {\n     color: var(--color-primary-dark);\n     text-decoration: underline;\n   }\n   \n   ::selection {\n     /* Style text selection using brand colors */\n     background-color: var(--color-primary-light);\n     color: var(--color-text-on-primary);\n   }\n   ```\n3. If scrollbar customization is required in the design-ref, implement cross-browser compatible scrollbar styling:\n   ```css\n   /* For Webkit browsers (Chrome, Safari) */\n   ::-webkit-scrollbar {\n     width: 8px;\n     height: 8px;\n   }\n   \n   ::-webkit-scrollbar-track {\n     background: var(--color-background-alt);\n   }\n   \n   ::-webkit-scrollbar-thumb {\n     background-color: var(--color-border);\n     border-radius: 4px;\n   }\n   \n   /* For Firefox */\n   * {\n     scrollbar-width: thin;\n     scrollbar-color: var(--color-border) var(--color-background-alt);\n   }\n   ```\n4. Add mobile-safe defaults to prevent common issues:\n   ```css\n   /* Prevent text inflation on mobile Safari */\n   body {\n     -webkit-font-smoothing: antialiased;\n     -moz-osx-font-smoothing: grayscale;\n   }\n   \n   /* Prevent iOS tap highlight */\n   a, button {\n     -webkit-tap-highlight-color: transparent;\n   }\n   \n   /* Improve form element rendering */\n   input, button, textarea, select {\n     font: inherit;\n   }\n   ```\n5. Import the base.css file into globals.css:\n   ```css\n   @import './tokens.css';\n   @import './typography.css';\n   @import './base.css';\n   \n   /* Other global styles */\n   ```\n6. Review design-ref for any additional base element styling requirements and implement them",
        "testStrategy": "1. Verify that base.css is correctly created and imported into globals.css\n2. Test the base styles across multiple browsers (Chrome, Firefox, Safari, Edge) to ensure consistent rendering\n3. Validate mobile compatibility by testing on various device sizes using browser dev tools:\n   - iPhone SE (smallest common size)\n   - iPhone 12/13 (medium size)\n   - iPad/tablet sizes\n4. Check that all styles are using CSS variables from the tokens system rather than hardcoded values\n5. Validate that text selection styling matches the design-ref\n6. Test scrollbar styling (if implemented) across different browsers\n7. Verify that links have proper states (normal, hover, focus, visited) matching the design-ref\n8. Test accessibility of the base styles:\n   - Ensure sufficient color contrast for text elements\n   - Verify focus states are visible for keyboard navigation\n9. Test the responsive behavior of the base styles at different viewport widths\n10. Validate that mobile-safe defaults are working by testing on actual mobile devices or emulators",
        "status": "pending",
        "dependencies": [
          2,
          3
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Create Shared Layout Primitives",
        "description": "Develop reusable layout components (Container, AppHeader, AppFooter, Section) and implement them in app/layout.tsx and core pages to establish a consistent application structure.",
        "details": "1. Create a new directory `src/components/layout/` to house all layout primitive components\n2. Implement the following layout components with TypeScript and CSS:\n\n   a. Container component:\n   ```tsx\n   // src/components/layout/Container.tsx\n   import React from 'react';\n   import styles from './Container.module.css';\n   \n   type ContainerProps = {\n     children: React.ReactNode;\n     maxWidth?: 'sm' | 'md' | 'lg' | 'xl' | 'full';\n     padding?: boolean;\n     className?: string;\n   };\n   \n   export function Container({ \n     children, \n     maxWidth = 'lg', \n     padding = true, \n     className = '' \n   }: ContainerProps) {\n     return (\n       <div className={`${styles.container} ${styles[maxWidth]} ${padding ? styles.padding : ''} ${className}`}>\n         {children}\n       </div>\n     );\n   }\n   ```\n\n   b. AppHeader component:\n   ```tsx\n   // src/components/layout/AppHeader.tsx\n   import React from 'react';\n   import Link from 'next/link';\n   import { Container } from './Container';\n   import styles from './AppHeader.module.css';\n   \n   type AppHeaderProps = {\n     className?: string;\n   };\n   \n   export function AppHeader({ className = '' }: AppHeaderProps) {\n     return (\n       <header className={`${styles.header} ${className}`}>\n         <Container>\n           <div className={styles.headerContent}>\n             <Link href=\"/\" className={styles.logo}>\n               {/* Logo component or image will go here */}\n               AppName\n             </Link>\n             <nav className={styles.navigation}>\n               {/* Navigation items will go here */}\n             </nav>\n           </div>\n         </Container>\n       </header>\n     );\n   }\n   ```\n\n   c. AppFooter component:\n   ```tsx\n   // src/components/layout/AppFooter.tsx\n   import React from 'react';\n   import { Container } from './Container';\n   import styles from './AppFooter.module.css';\n   \n   type AppFooterProps = {\n     className?: string;\n   };\n   \n   export function AppFooter({ className = '' }: AppFooterProps) {\n     return (\n       <footer className={`${styles.footer} ${className}`}>\n         <Container>\n           <div className={styles.footerContent}>\n             {/* Footer content will go here */}\n             <p className={styles.copyright}>© {new Date().getFullYear()} AppName. All rights reserved.</p>\n           </div>\n         </Container>\n       </footer>\n     );\n   }\n   ```\n\n   d. Section component:\n   ```tsx\n   // src/components/layout/Section.tsx\n   import React from 'react';\n   import styles from './Section.module.css';\n   \n   type SectionProps = {\n     children: React.ReactNode;\n     className?: string;\n     background?: 'primary' | 'secondary' | 'light' | 'dark' | 'none';\n     spacing?: 'sm' | 'md' | 'lg' | 'xl' | 'none';\n   };\n   \n   export function Section({ \n     children, \n     className = '', \n     background = 'none',\n     spacing = 'md'\n   }: SectionProps) {\n     return (\n       <section className={`${styles.section} ${styles[`bg-${background}`]} ${styles[`spacing-${spacing}`]} ${className}`}>\n         {children}\n       </section>\n     );\n   }\n   ```\n\n3. Create corresponding CSS module files for each component, utilizing the design tokens:\n   - Container.module.css\n   - AppHeader.module.css\n   - AppFooter.module.css\n   - Section.module.css\n\n4. Create an index.ts file to export all layout components:\n   ```tsx\n   // src/components/layout/index.ts\n   export * from './Container';\n   export * from './AppHeader';\n   export * from './AppFooter';\n   export * from './Section';\n   ```\n\n5. Implement the layout components in the app/layout.tsx file:\n   ```tsx\n   // app/layout.tsx\n   import { AppHeader, AppFooter } from '@/components/layout';\n   import '@/styles/globals.css';\n   \n   export default function RootLayout({\n     children,\n   }: {\n     children: React.ReactNode;\n   }) {\n     return (\n       <html lang=\"en\">\n         <body>\n           <AppHeader />\n           <main>\n             {children}\n           </main>\n           <AppFooter />\n         </body>\n       </html>\n     );\n   }\n   ```\n\n6. Update core pages to use the layout primitives:\n   - Modify the home page (app/page.tsx)\n   - Update any other existing core pages to use the new layout components\n\n7. Ensure all layout components are responsive and adapt to different screen sizes by implementing appropriate media queries in the CSS modules.",
        "testStrategy": "1. Unit test each layout component:\n   - Verify Container renders with different maxWidth and padding props\n   - Test AppHeader renders with navigation elements\n   - Confirm AppFooter displays correctly with copyright information\n   - Validate Section component with various background and spacing options\n\n2. Integration testing:\n   - Verify that app/layout.tsx correctly incorporates AppHeader and AppFooter\n   - Test that the layout structure renders properly on all core pages\n   - Ensure proper nesting of components (e.g., Container inside Section)\n\n3. Responsive design testing:\n   - Test all layout components at various viewport sizes:\n     - Mobile (320px - 480px)\n     - Tablet (481px - 768px)\n     - Laptop (769px - 1024px)\n     - Desktop (1025px+)\n   - Verify that components adapt appropriately at each breakpoint\n   - Check for any overflow issues or layout shifts\n\n4. Accessibility testing:\n   - Verify proper semantic HTML structure in all layout components\n   - Test keyboard navigation through header and footer elements\n   - Ensure appropriate ARIA attributes are used where needed\n   - Validate color contrast meets WCAG standards\n\n5. Visual regression testing:\n   - Compare layout rendering against design specifications\n   - Ensure consistent spacing, alignment, and visual hierarchy\n   - Verify that design tokens are properly applied to all components\n\n6. Cross-browser testing:\n   - Test layout components in Chrome, Firefox, Safari, and Edge\n   - Verify consistent rendering across all supported browsers",
        "status": "pending",
        "dependencies": [
          2,
          3,
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Refactor Core UI Components with Design Token Integration",
        "description": "Refactor core UI components (Button, Textarea/Input, Card, Modal, Badge, Skeleton) to use the new design tokens system, adding interactive states (hover/active/disabled) and focus rings for accessibility.",
        "details": "1. Create a new directory structure for the core UI components:\n```\nsrc/components/ui/\n  ├── Button/\n  │   ├── Button.tsx\n  │   ├── Button.module.css\n  │   └── index.ts\n  ├── Input/\n  │   ├── Input.tsx\n  │   ├── Textarea.tsx\n  │   ├── Input.module.css\n  │   └── index.ts\n  ├── Card/\n  │   ├── Card.tsx\n  │   ├── Card.module.css\n  │   └── index.ts\n  ├── Modal/\n  │   ├── Modal.tsx\n  │   ├── Modal.module.css\n  │   └── index.ts\n  ├── Badge/\n  │   ├── Badge.tsx\n  │   ├── Badge.module.css\n  │   └── index.ts\n  ├── Skeleton/\n  │   ├── Skeleton.tsx\n  │   ├── Skeleton.module.css\n  │   └── index.ts\n  └── index.ts\n```\n\n2. For each component, implement the following:\n\n   a. Button component:\n   ```tsx\n   // src/components/ui/Button/Button.tsx\n   import React from 'react';\n   import styles from './Button.module.css';\n   \n   type ButtonVariant = 'primary' | 'secondary' | 'tertiary' | 'ghost' | 'danger';\n   type ButtonSize = 'sm' | 'md' | 'lg';\n   \n   export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n     variant?: ButtonVariant;\n     size?: ButtonSize;\n     isFullWidth?: boolean;\n     leftIcon?: React.ReactNode;\n     rightIcon?: React.ReactNode;\n     isLoading?: boolean;\n     loadingText?: string;\n     children: React.ReactNode;\n   }\n   \n   export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n     (\n       {\n         variant = 'primary',\n         size = 'md',\n         isFullWidth = false,\n         leftIcon,\n         rightIcon,\n         isLoading = false,\n         loadingText,\n         children,\n         className = '',\n         disabled = false,\n         ...props\n       },\n       ref\n     ) => {\n       const buttonClasses = [\n         styles.button,\n         styles[`variant-${variant}`],\n         styles[`size-${size}`],\n         isFullWidth ? styles.fullWidth : '',\n         disabled ? styles.disabled : '',\n         className,\n       ]\n         .filter(Boolean)\n         .join(' ');\n   \n       return (\n         <button\n           ref={ref}\n           className={buttonClasses}\n           disabled={disabled || isLoading}\n           {...props}\n         >\n           {isLoading ? (\n             <>\n               <span className={styles.loadingSpinner} />\n               {loadingText || children}\n             </>\n           ) : (\n             <>\n               {leftIcon && <span className={styles.leftIcon}>{leftIcon}</span>}\n               {children}\n               {rightIcon && <span className={styles.rightIcon}>{rightIcon}</span>}\n             </>\n           )}\n         </button>\n       );\n     }\n   );\n   \n   Button.displayName = 'Button';\n   ```\n\n   ```css\n   /* src/components/ui/Button/Button.module.css */\n   .button {\n     display: inline-flex;\n     align-items: center;\n     justify-content: center;\n     gap: var(--spacing-2);\n     border-radius: var(--radius-md);\n     font-weight: var(--font-weight-medium);\n     transition: all 0.2s ease-in-out;\n     cursor: pointer;\n     position: relative;\n     overflow: hidden;\n   }\n   \n   /* Variants */\n   .variant-primary {\n     background-color: var(--color-primary);\n     color: var(--color-primary-contrast);\n     border: none;\n   }\n   \n   .variant-primary:hover:not(.disabled) {\n     background-color: var(--color-primary-hover);\n   }\n   \n   .variant-primary:active:not(.disabled) {\n     background-color: var(--color-primary-active);\n   }\n   \n   /* Add similar styles for secondary, tertiary, ghost, and danger variants */\n   \n   /* Sizes */\n   .size-sm {\n     height: var(--size-8);\n     padding: 0 var(--spacing-3);\n     font-size: var(--font-size-sm);\n   }\n   \n   .size-md {\n     height: var(--size-10);\n     padding: 0 var(--spacing-4);\n     font-size: var(--font-size-md);\n   }\n   \n   .size-lg {\n     height: var(--size-12);\n     padding: 0 var(--spacing-5);\n     font-size: var(--font-size-lg);\n   }\n   \n   /* Full width */\n   .fullWidth {\n     width: 100%;\n   }\n   \n   /* Focus state */\n   .button:focus-visible {\n     outline: none;\n     box-shadow: 0 0 0 2px var(--color-background), 0 0 0 4px var(--color-primary);\n   }\n   \n   /* Disabled state */\n   .disabled {\n     opacity: 0.6;\n     cursor: not-allowed;\n   }\n   \n   /* Loading spinner */\n   .loadingSpinner {\n     /* Implement spinner using CSS or SVG */\n   }\n   \n   /* Icon positioning */\n   .leftIcon, .rightIcon {\n     display: inline-flex;\n     align-items: center;\n   }\n   ```\n\n3. Implement similar patterns for the other components:\n\n   b. Input/Textarea component with states for focus, hover, error, and disabled\n   c. Card component with various padding options and border styles\n   d. Modal component with backdrop, animations, and close button\n   e. Badge component with different variants (status, notification, etc.)\n   f. Skeleton component for loading states with animation\n\n4. For each component, ensure:\n   - All colors, spacing, typography, and other visual properties use CSS variables from the tokens system\n   - Interactive states (hover, active, focus, disabled) are properly styled\n   - Focus rings are implemented for keyboard navigation accessibility\n   - Components are responsive and work across different screen sizes\n   - Dark mode support is implemented using the theme tokens\n\n5. Create an index.ts file in each component directory to export the component:\n   ```tsx\n   // src/components/ui/Button/index.ts\n   export * from './Button';\n   ```\n\n6. Create a main index.ts file to export all components:\n   ```tsx\n   // src/components/ui/index.ts\n   export * from './Button';\n   export * from './Input';\n   export * from './Card';\n   export * from './Modal';\n   export * from './Badge';\n   export * from './Skeleton';\n   ```\n\n7. Update any existing usage of these components throughout the application to use the new refactored versions.",
        "testStrategy": "1. Create a comprehensive test suite for each component:\n\n   a. Unit tests for each component using React Testing Library:\n   ```tsx\n   // src/components/ui/Button/Button.test.tsx\n   import { render, screen, fireEvent } from '@testing-library/react';\n   import { Button } from './Button';\n   \n   describe('Button component', () => {\n     test('renders correctly with default props', () => {\n       render(<Button>Click me</Button>);\n       const button = screen.getByRole('button', { name: /click me/i });\n       expect(button).toBeInTheDocument();\n       expect(button).toHaveClass('variant-primary');\n       expect(button).toHaveClass('size-md');\n     });\n     \n     test('applies variant classes correctly', () => {\n       const { rerender } = render(<Button variant=\"secondary\">Button</Button>);\n       expect(screen.getByRole('button')).toHaveClass('variant-secondary');\n       \n       rerender(<Button variant=\"danger\">Button</Button>);\n       expect(screen.getByRole('button')).toHaveClass('variant-danger');\n     });\n     \n     test('handles disabled state correctly', () => {\n       render(<Button disabled>Disabled</Button>);\n       const button = screen.getByRole('button');\n       expect(button).toBeDisabled();\n       expect(button).toHaveClass('disabled');\n     });\n     \n     test('handles loading state correctly', () => {\n       render(<Button isLoading loadingText=\"Loading...\">Click me</Button>);\n       expect(screen.getByText('Loading...')).toBeInTheDocument();\n       expect(screen.getByRole('button')).toBeDisabled();\n     });\n     \n     test('executes onClick handler when clicked', () => {\n       const handleClick = jest.fn();\n       render(<Button onClick={handleClick}>Click me</Button>);\n       fireEvent.click(screen.getByRole('button'));\n       expect(handleClick).toHaveBeenCalledTimes(1);\n     });\n   });\n   ```\n\n2. Create similar test suites for each component, testing their specific functionality and states.\n\n3. Create visual regression tests using Storybook:\n   a. Set up Storybook stories for each component showing different variants, states, and sizes\n   b. Use Storybook's accessibility addon to verify WCAG compliance\n   c. Use Chromatic or a similar tool to capture and compare visual snapshots\n\n4. Create a component playground page in the application:\n   a. Implement a page that showcases all UI components in their various states\n   b. Include interactive controls to toggle between states (hover, focus, active, disabled)\n   c. Show components in both light and dark mode\n\n5. Accessibility testing:\n   a. Verify all components are keyboard navigable\n   b. Ensure focus states are clearly visible\n   c. Test with screen readers to confirm proper ARIA attributes\n   d. Run automated accessibility tests using axe or similar tools\n\n6. Cross-browser testing:\n   a. Test components in Chrome, Firefox, Safari, and Edge\n   b. Verify mobile compatibility on iOS and Android devices\n\n7. Performance testing:\n   a. Measure bundle size impact of the new components\n   b. Test rendering performance, especially for components that might appear in lists\n\n8. Integration testing:\n   a. Create tests that verify components work correctly when used together\n   b. Test form submissions with the new Input components\n   c. Test modal dialogs with forms and buttons inside them",
        "status": "pending",
        "dependencies": [
          2,
          3,
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Apply New Design to Chat UI Components",
        "description": "Update the Chat UI components with the new design system, including message bubbles, avatars, wrap-up modal, and composer bar while preserving all existing functionality.",
        "details": "1. Identify all Chat UI components that need styling updates:\n   - Message bubbles (user and assistant)\n   - User and assistant avatars\n   - Wrap-up modal (end of conversation)\n   - Composer bar (text input and controls)\n\n2. Create or update component-specific CSS modules:\n   ```\n   src/components/chat/\n   ├── MessageBubble/\n   │   ├── MessageBubble.tsx\n   │   ├── MessageBubble.module.css\n   │   └── index.ts\n   ├── Avatar/\n   │   ├── Avatar.tsx\n   │   ├── Avatar.module.css\n   │   └── index.ts\n   ├── WrapUpModal/\n   │   ├── WrapUpModal.tsx\n   │   ├── WrapUpModal.module.css\n   │   └── index.ts\n   ├── ComposerBar/\n   │   ├── ComposerBar.tsx\n   │   ├── ComposerBar.module.css\n   │   └── index.ts\n   ```\n\n3. Update MessageBubble component:\n   - Apply different styling for user vs. assistant messages\n   - Implement proper border radius using design tokens\n   - Add appropriate padding and margins\n   - Ensure proper text wrapping and overflow handling\n   - Add timestamp display with correct typography\n   - Implement status indicators (sending, sent, error)\n\n4. Enhance Avatar component:\n   - Support for both user and assistant avatars\n   - Implement proper sizing and border radius\n   - Add fallback initials display when image is unavailable\n   - Support for status indicators (online, typing, etc.)\n\n5. Redesign WrapUpModal:\n   - Apply modal styling from the core UI components\n   - Ensure proper spacing and layout for content\n   - Style action buttons according to design system\n   - Add animations for modal entry/exit\n\n6. Update ComposerBar:\n   - Style text input area with proper padding and height\n   - Implement send button with proper states (disabled, hover, active)\n   - Add attachment/emoji button styling\n   - Ensure proper mobile responsiveness\n\n7. Ensure all components use design tokens for:\n   - Colors (background, text, borders)\n   - Typography (font family, size, weight)\n   - Spacing (padding, margins)\n   - Border radius\n   - Shadows and elevations\n\n8. Preserve all existing functionality:\n   - Message sending/receiving\n   - Error handling\n   - Loading states\n   - User interactions\n   - Accessibility features\n\n9. Add responsive design considerations:\n   - Adjust layout for different screen sizes\n   - Ensure touch-friendly targets on mobile\n   - Test with different content lengths",
        "testStrategy": "1. Visual comparison testing:\n   - Create side-by-side screenshots of old vs. new design\n   - Verify all design elements match the design-ref specifications\n   - Check both light and dark mode appearances\n\n2. Functional testing:\n   - Verify all existing chat functionality works as before:\n     - Sending messages\n     - Receiving messages\n     - Error states\n     - Loading states\n     - Modal interactions\n   - Test with various message lengths (short, long, code blocks)\n   - Verify emoji and special character rendering\n\n3. Responsive testing:\n   - Test on multiple viewport sizes (mobile, tablet, desktop)\n   - Verify layout adjusts appropriately\n   - Check touch interactions on mobile devices\n\n4. Accessibility testing:\n   - Verify color contrast meets WCAG standards\n   - Test keyboard navigation through the chat interface\n   - Ensure screen readers can properly interpret the UI\n   - Verify focus states are visible and follow design system\n\n5. Cross-browser testing:\n   - Test in Chrome, Firefox, Safari, and Edge\n   - Verify consistent appearance and behavior\n\n6. Integration testing:\n   - Test the chat UI within the full application context\n   - Verify interactions with other components work correctly\n\n7. Create a test page that demonstrates:\n   - Different message types (user/assistant)\n   - Various states (typing, sent, error)\n   - Modal interactions\n   - Responsive behavior",
        "status": "pending",
        "dependencies": [
          2,
          3,
          6
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Restyle Key Pages Using Layout Primitives and Design Tokens",
        "description": "Apply the new design system to key pages (home, onboarding, session detail, report, why) using the shared layout primitives and design tokens while preserving existing copy and functionality.",
        "details": "1. Identify the key pages that need restyling:\n   - Home page (`src/app/page.tsx`)\n   - Onboarding pages (`src/app/onboarding/`)\n   - Session detail page (`src/app/sessions/[id]/page.tsx`)\n   - Report page (`src/app/reports/[id]/page.tsx`)\n   - Why page (`src/app/why/page.tsx`)\n\n2. For each page, implement the following changes:\n   \n   a. Update page structure using layout primitives:\n   ```tsx\n   // Example for home page (src/app/page.tsx)\n   import { Container, Section, AppHeader, AppFooter } from '@/components/layout';\n   \n   export default function HomePage() {\n     return (\n       <>\n         <AppHeader />\n         <main>\n           <Section background=\"light\">\n             <Container maxWidth=\"lg\">\n               {/* Hero content */}\n             </Container>\n           </Section>\n           \n           <Section background=\"alternate\">\n             <Container maxWidth=\"md\">\n               {/* Features content */}\n             </Container>\n           </Section>\n           \n           {/* Additional sections */}\n         </main>\n         <AppFooter />\n       </>\n     );\n   }\n   ```\n   \n   b. Apply design tokens to all styling:\n   - Replace hardcoded color values with token variables\n   - Update typography using the type system\n   - Apply spacing tokens for margins and padding\n   - Use border-radius tokens for rounded elements\n   \n   c. Update CSS modules for each page:\n   ```css\n   /* Example: src/app/page.module.css */\n   .hero {\n     display: flex;\n     flex-direction: column;\n     gap: var(--spacing-8);\n     padding: var(--spacing-12) 0;\n   }\n   \n   .heroTitle {\n     font-size: var(--font-size-3xl);\n     font-weight: var(--font-weight-bold);\n     color: var(--color-text-primary);\n     line-height: var(--line-height-tight);\n   }\n   \n   /* Additional styles */\n   ```\n   \n3. Ensure responsive design implementation:\n   - Test and adjust layouts for mobile, tablet, and desktop viewports\n   - Use CSS Grid and Flexbox with appropriate breakpoints\n   - Implement responsive typography using clamp() where appropriate\n   \n4. Preserve all existing functionality:\n   - Maintain all interactive elements and their behaviors\n   - Keep all copy text unchanged\n   - Ensure all links and navigation paths remain functional\n   \n5. Implement dark mode support for all restyled pages:\n   - Test pages with both light and dark mode preferences\n   - Ensure all components respect the color scheme tokens\n\n6. Optimize for performance:\n   - Use CSS modules to scope styles to components\n   - Minimize CSS specificity conflicts\n   - Avoid unnecessary nesting of selectors",
        "testStrategy": "1. Visual comparison testing:\n   - Create side-by-side screenshots of old vs. new designs for each page\n   - Verify all design elements match the design-ref specifications\n   - Check both light and dark mode appearances\n   \n2. Responsive design testing:\n   - Test each page at standard breakpoints (320px, 768px, 1024px, 1440px)\n   - Verify content remains readable and properly laid out at all viewport sizes\n   - Test with browser dev tools and actual devices when possible\n   \n3. Functional testing:\n   - Verify all interactive elements work as before:\n     - Links navigate to correct destinations\n     - Forms submit properly\n     - Buttons trigger appropriate actions\n     - Modals open and close correctly\n   \n4. Accessibility testing:\n   - Run Lighthouse accessibility audits on each page\n   - Test keyboard navigation through all interactive elements\n   - Verify proper focus states are visible\n   - Check color contrast ratios meet WCAG AA standards\n   \n5. Cross-browser testing:\n   - Test in Chrome, Firefox, Safari, and Edge\n   - Verify consistent appearance and behavior across browsers\n   \n6. Performance testing:\n   - Run Lighthouse performance audits\n   - Check for any CSS bloat or unnecessary style rules\n   - Verify no layout shifts occur during page load\n   \n7. Code review:\n   - Ensure consistent use of layout primitives across pages\n   - Verify design tokens are used instead of hardcoded values\n   - Check that no existing functionality was removed or broken",
        "status": "pending",
        "dependencies": [
          5,
          2,
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Dark Mode Support for Design System",
        "description": "Implement dark mode support using prefers-color-scheme media queries for all design tokens and components, ensuring proper contrast ratios and smooth transitions between light and dark themes.",
        "details": "1. Update the design tokens system to support dark mode:\n   ```css\n   /* In src/styles/tokens.css */\n   :root {\n     /* Light theme colors (default) */\n     --color-background: #ffffff;\n     --color-text-primary: #1a1a1a;\n     --color-text-secondary: #4a4a4a;\n     --color-primary: #3b82f6;\n     --color-secondary: #6b7280;\n     --color-accent: #8b5cf6;\n     --color-success: #10b981;\n     --color-warning: #f59e0b;\n     --color-error: #ef4444;\n     --color-border: #e5e7eb;\n     --color-card-bg: #ffffff;\n     /* Additional light theme tokens... */\n   }\n\n   @media (prefers-color-scheme: dark) {\n     :root {\n       /* Dark theme colors */\n       --color-background: #121212;\n       --color-text-primary: #f3f4f6;\n       --color-text-secondary: #d1d5db;\n       --color-primary: #60a5fa;\n       --color-secondary: #9ca3af;\n       --color-accent: #a78bfa;\n       --color-success: #34d399;\n       --color-warning: #fbbf24;\n       --color-error: #f87171;\n       --color-border: #374151;\n       --color-card-bg: #1f2937;\n       /* Additional dark theme tokens... */\n     }\n   }\n   ```\n\n2. Add transition properties for smooth theme switching:\n   ```css\n   /* In src/styles/base.css */\n   html {\n     /* Add smooth transition for color changes */\n     transition: background-color 0.3s ease, color 0.3s ease;\n   }\n   \n   body, button, input, textarea, select {\n     transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;\n   }\n   ```\n\n3. Verify and adjust contrast ratios for all color combinations:\n   - Use a color contrast checker tool to ensure all text meets WCAG AA standards (4.5:1 for normal text, 3:1 for large text)\n   - Adjust dark mode color values as needed to maintain proper contrast\n   - Document any special color adjustments in comments\n\n4. Update component-specific styles to handle dark mode properly:\n   - Review all UI components (Button, Card, Modal, etc.) to ensure they respond correctly to dark mode\n   - Pay special attention to shadows, borders, and background colors\n   - Example for Button component:\n   ```css\n   /* In src/components/ui/Button/Button.module.css */\n   .button {\n     background-color: var(--color-primary);\n     color: white;\n     /* Other button styles... */\n   }\n   \n   .secondary {\n     background-color: var(--color-secondary);\n     /* Other secondary button styles... */\n   }\n   \n   /* No need for separate dark mode styles if using CSS variables properly */\n   ```\n\n5. Create a theme toggle component (optional enhancement):\n   ```tsx\n   // src/components/ui/ThemeToggle/ThemeToggle.tsx\n   import { useState, useEffect } from 'react';\n   import styles from './ThemeToggle.module.css';\n   \n   export const ThemeToggle = () => {\n     const [isDarkMode, setIsDarkMode] = useState(false);\n     \n     useEffect(() => {\n       // Check initial preference\n       const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n       setIsDarkMode(prefersDark);\n       \n       // Listen for changes\n       const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\n       const handleChange = (e: MediaQueryListEvent) => setIsDarkMode(e.matches);\n       \n       mediaQuery.addEventListener('change', handleChange);\n       return () => mediaQuery.removeEventListener('change', handleChange);\n     }, []);\n     \n     return (\n       <button \n         className={styles.toggle}\n         aria-label={isDarkMode ? 'Switch to light mode' : 'Switch to dark mode'}\n       >\n         {isDarkMode ? '☀️' : '🌙'}\n       </button>\n     );\n   };\n   ```\n\n6. Test dark mode appearance across all pages and components:\n   - Create a dark mode testing checklist covering all UI elements\n   - Verify that all components maintain their functionality in dark mode\n   - Check for any unintended color or contrast issues",
        "testStrategy": "1. Automated contrast testing:\n   - Use a tool like axe-core to programmatically test color contrast ratios\n   - Create a script that validates all color combinations against WCAG AA standards\n   - Run this test for both light and dark mode color tokens\n\n2. Visual regression testing:\n   - Capture screenshots of all key components and pages in both light and dark modes\n   - Compare them side-by-side to ensure consistent styling\n   - Use a tool like Percy or Chromatic to automate this process\n\n3. Browser compatibility testing:\n   - Test dark mode support in all major browsers (Chrome, Firefox, Safari, Edge)\n   - Verify that the prefers-color-scheme media query works correctly\n   - Test on both desktop and mobile devices\n\n4. Transition testing:\n   - Test the smoothness of transitions when switching between light and dark modes\n   - Verify that no elements flicker or display incorrectly during transition\n   - Ensure transition timing is consistent across all elements\n\n5. Manual accessibility testing:\n   - Use screen readers to verify that dark mode doesn't affect accessibility\n   - Check keyboard navigation in both light and dark modes\n   - Verify that focus indicators remain visible in dark mode\n\n6. User preference testing:\n   - Test that the system correctly detects and applies the user's system preference\n   - Verify that the theme updates automatically when the system preference changes\n   - If implementing a manual toggle, test that it works correctly and persists user choice\n\n7. Create a dark mode testing page:\n   - Develop a page that displays all components in both light and dark modes\n   - Include text samples at various sizes to verify readability\n   - Use this page for quick visual verification during development",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Accessibility Improvements for Chat Controls",
        "description": "Perform an accessibility audit and enhancement pass focusing on color contrast, focus order, keyboard navigation, and ARIA labels in chat controls, ensuring WCAG AA compliance.",
        "details": "1. Color Contrast Improvements:\n   - Audit all text and UI elements in the chat interface against WCAG AA standards (4.5:1 for normal text, 3:1 for large text)\n   - Update color tokens in both light and dark mode to ensure proper contrast\n   - Pay special attention to interactive elements like buttons and links in the chat composer\n\n2. Focus Order Optimization:\n   - Map the current tab order through the chat interface\n   - Restructure DOM elements where necessary to create a logical tab sequence\n   - Ensure focus indicators are visible and consistent with the design system\n   - Implement proper focus management when chat modals appear\n\n3. Keyboard Navigation Enhancements:\n   - Ensure all interactive elements are keyboard accessible\n   - Add keyboard shortcuts for common chat actions (send message, cancel, etc.)\n   - Implement arrow key navigation for message history\n   - Add proper keyboard trap handling for modals and popups\n   - Document all keyboard shortcuts in the accessibility documentation\n\n4. ARIA Implementation:\n   - Add appropriate ARIA roles to chat components:\n     ```tsx\n     // Example for message list\n     <div role=\"log\" aria-live=\"polite\" aria-label=\"Chat messages\">\n       {messages.map(message => (\n         <MessageBubble key={message.id} message={message} />\n       ))}\n     </div>\n     ```\n   - Implement aria-labels for all controls lacking visible text labels\n   - Add aria-expanded, aria-pressed, and other relevant states to interactive elements\n   - Ensure proper announcement of new messages and status changes\n\n5. Documentation:\n   - Create an accessibility.md file documenting all accessibility decisions\n   - Include rationale for implementation choices\n   - Document any known limitations and future improvements\n   - Add code comments explaining complex accessibility implementations",
        "testStrategy": "1. Automated Testing:\n   - Run axe-core accessibility tests against all chat components\n   - Verify color contrast using tools like Contrast Checker or Lighthouse\n   - Create automated tests for keyboard navigation paths\n   - Test with screen readers (NVDA, VoiceOver) programmatically where possible\n\n2. Manual Testing:\n   - Perform keyboard-only navigation testing through the entire chat flow\n   - Test with screen readers on multiple platforms:\n     - NVDA or JAWS on Windows\n     - VoiceOver on macOS/iOS\n     - TalkBack on Android\n   - Verify focus visibility and logical tab order\n   - Test color contrast in both light and dark modes\n\n3. User Testing:\n   - If possible, conduct testing with users who rely on assistive technologies\n   - Document feedback and implement critical improvements\n\n4. Documentation Verification:\n   - Review accessibility documentation for completeness\n   - Ensure all keyboard shortcuts are documented\n   - Verify that implementation decisions are clearly explained\n\n5. Regression Testing:\n   - Create a checklist of accessibility features to verify in future releases\n   - Implement automated accessibility tests in the CI pipeline",
        "status": "pending",
        "dependencies": [
          7,
          9,
          6
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement First-Time Report Onboarding Experience",
        "description": "Create an enhanced onboarding experience for first-time report generation on the /session/[id]/report page, including scripted messages, conditional UI elements, and automatic navigation to the why report upon completion.",
        "details": "1. Update the report generation page at `/session/[id]/report` to detect first-time report generation:\n```tsx\n// In src/app/session/[id]/report/page.tsx\nimport { useReportStatus } from '@/hooks/useReportStatus';\n\nconst ReportPage = ({ params }) => {\n  const { id } = params;\n  const { hasExistingReport, isGenerating } = useReportStatus(id);\n  const isFirstTimeGeneration = !hasExistingReport && isGenerating;\n  \n  // Rest of component...\n}\n```\n\n2. Create a new component for the scripted onboarding messages:\n```tsx\n// In src/components/report/OnboardingMessages.tsx\nimport { useState, useEffect } from 'react';\nimport styles from './OnboardingMessages.module.css';\n\nconst messages = [\n  \"AI가 당신의 대화를 분석하고 있어요...\",\n  \"당신의 대화 패턴을 파악하고 있어요...\",\n  \"Why 보고서를 생성하고 있어요...\",\n  \"거의 완료되었어요...\"\n];\n\nexport const OnboardingMessages = ({ isVisible, onComplete }) => {\n  const [currentMessageIndex, setCurrentMessageIndex] = useState(0);\n  \n  useEffect(() => {\n    if (!isVisible) return;\n    \n    const interval = setInterval(() => {\n      if (currentMessageIndex < messages.length - 1) {\n        setCurrentMessageIndex(prev => prev + 1);\n      } else {\n        clearInterval(interval);\n        onComplete();\n      }\n    }, 3000); // Show each message for 3 seconds\n    \n    return () => clearInterval(interval);\n  }, [currentMessageIndex, isVisible, onComplete]);\n  \n  if (!isVisible) return null;\n  \n  return (\n    <div className={styles.onboardingContainer}>\n      <div className={styles.messageBox}>\n        {messages[currentMessageIndex]}\n      </div>\n    </div>\n  );\n};\n```\n\n3. Create a conditional \"나의 why 보고서\" button that enables when generation completes:\n```tsx\n// In src/components/report/WhyReportButton.tsx\nimport { Button } from '@/components/ui/Button';\nimport styles from './WhyReportButton.module.css';\n\nexport const WhyReportButton = ({ isDisabled, sessionId, onClick }) => {\n  return (\n    <Button \n      className={styles.whyReportButton}\n      disabled={isDisabled}\n      onClick={onClick}\n    >\n      나의 why 보고서\n    </Button>\n  );\n};\n```\n\n4. Implement auto-navigation to the why report page after generation completes:\n```tsx\n// In src/app/session/[id]/report/page.tsx\nimport { useRouter } from 'next/navigation';\n\nconst ReportPage = ({ params }) => {\n  const router = useRouter();\n  const { id } = params;\n  const { hasExistingReport, isGenerating, isComplete } = useReportStatus(id);\n  const isFirstTimeGeneration = !hasExistingReport && isGenerating;\n  const [onboardingComplete, setOnboardingComplete] = useState(false);\n  \n  // Handle auto-navigation after first-time generation\n  useEffect(() => {\n    if (isFirstTimeGeneration && isComplete && onboardingComplete) {\n      // Navigate to the why report page\n      router.push(`/session/${id}/why`);\n    }\n  }, [isFirstTimeGeneration, isComplete, onboardingComplete, id, router]);\n  \n  const handleWhyReportClick = () => {\n    router.push(`/session/${id}/why`);\n  };\n  \n  return (\n    <div>\n      {/* Existing minimal loading UI for returning users */}\n      {!isFirstTimeGeneration && isGenerating && (\n        <div className={styles.loadingContainer}>\n          <LoadingSpinner />\n          <p>보고서를 생성하고 있어요...</p>\n        </div>\n      )}\n      \n      {/* New onboarding experience for first-time users */}\n      {isFirstTimeGeneration && (\n        <>\n          <OnboardingMessages \n            isVisible={true} \n            onComplete={() => setOnboardingComplete(true)} \n          />\n          <WhyReportButton \n            isDisabled={!isComplete} \n            sessionId={id}\n            onClick={handleWhyReportClick}\n          />\n        </>\n      )}\n      \n      {/* Rest of the component */}\n    </div>\n  );\n};\n```\n\n5. Add CSS styles for the new components:\n```css\n/* src/components/report/OnboardingMessages.module.css */\n.onboardingContainer {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  min-height: 200px;\n  margin: 2rem 0;\n}\n\n.messageBox {\n  padding: 1rem 2rem;\n  background-color: var(--color-card-bg);\n  border-radius: 8px;\n  box-shadow: var(--shadow-sm);\n  animation: fadeIn 0.5s ease-in-out;\n}\n\n@keyframes fadeIn {\n  from { opacity: 0; }\n  to { opacity: 1; }\n}\n```\n\n```css\n/* src/components/report/WhyReportButton.module.css */\n.whyReportButton {\n  margin-top: 2rem;\n  width: 100%;\n  max-width: 300px;\n  transition: opacity 0.3s ease;\n}\n\n.whyReportButton:disabled {\n  opacity: 0.6;\n  cursor: not-allowed;\n}\n```\n\n6. Ensure the cascade generation behavior remains intact by preserving the existing API calls and state management:\n```tsx\n// In src/hooks/useReportStatus.js\nexport const useReportStatus = (sessionId) => {\n  const [status, setStatus] = useState({\n    hasExistingReport: false,\n    isGenerating: false,\n    isComplete: false,\n    progress: 0\n  });\n  \n  useEffect(() => {\n    // Check if report exists\n    const checkReportStatus = async () => {\n      try {\n        const response = await fetch(`/api/sessions/${sessionId}/report/status`);\n        const data = await response.json();\n        \n        setStatus({\n          hasExistingReport: data.exists,\n          isGenerating: data.isGenerating,\n          isComplete: data.isComplete,\n          progress: data.progress || 0\n        });\n        \n        // If report is generating but not complete, poll for updates\n        if (data.isGenerating && !data.isComplete) {\n          setTimeout(checkReportStatus, 2000);\n        }\n      } catch (error) {\n        console.error('Failed to check report status:', error);\n      }\n    };\n    \n    checkReportStatus();\n  }, [sessionId]);\n  \n  return status;\n};\n```\n\n7. Update the report generation API to track first-time generation status:\n```typescript\n// In src/pages/api/sessions/[id]/report/generate.ts\nexport default async function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ message: 'Method not allowed' });\n  }\n  \n  const { id } = req.query;\n  \n  try {\n    // Check if report already exists\n    const existingReport = await db.report.findFirst({\n      where: { sessionId: id }\n    });\n    \n    const isFirstTimeGeneration = !existingReport;\n    \n    // Start report generation process\n    await startReportGeneration(id);\n    \n    return res.status(200).json({ \n      success: true, \n      isFirstTimeGeneration \n    });\n  } catch (error) {\n    console.error('Error generating report:', error);\n    return res.status(500).json({ message: 'Failed to generate report' });\n  }\n}\n```",
        "testStrategy": "1. Unit Testing:\n   - Create unit tests for the OnboardingMessages component:\n   ```tsx\n   // src/components/report/OnboardingMessages.test.tsx\n   import { render, screen, act } from '@testing-library/react';\n   import { OnboardingMessages } from './OnboardingMessages';\n   \n   jest.useFakeTimers();\n   \n   describe('OnboardingMessages', () => {\n     it('should not render when isVisible is false', () => {\n       render(<OnboardingMessages isVisible={false} onComplete={() => {}} />);\n       expect(screen.queryByText(/AI가 당신의 대화를 분석하고 있어요/)).not.toBeInTheDocument();\n     });\n     \n     it('should show the first message when rendered', () => {\n       render(<OnboardingMessages isVisible={true} onComplete={() => {}} />);\n       expect(screen.getByText(/AI가 당신의 대화를 분석하고 있어요/)).toBeInTheDocument();\n     });\n     \n     it('should cycle through messages and call onComplete', () => {\n       const onCompleteMock = jest.fn();\n       render(<OnboardingMessages isVisible={true} onComplete={onCompleteMock} />);\n       \n       // Advance through all messages\n       act(() => {\n         jest.advanceTimersByTime(3000);\n       });\n       expect(screen.getByText(/당신의 대화 패턴을 파악하고 있어요/)).toBeInTheDocument();\n       \n       act(() => {\n         jest.advanceTimersByTime(3000);\n       });\n       expect(screen.getByText(/Why 보고서를 생성하고 있어요/)).toBeInTheDocument();\n       \n       act(() => {\n         jest.advanceTimersByTime(3000);\n       });\n       expect(screen.getByText(/거의 완료되었어요/)).toBeInTheDocument();\n       \n       act(() => {\n         jest.advanceTimersByTime(3000);\n       });\n       expect(onCompleteMock).toHaveBeenCalledTimes(1);\n     });\n   });\n   ```\n   \n   - Test the WhyReportButton component:\n   ```tsx\n   // src/components/report/WhyReportButton.test.tsx\n   import { render, screen, fireEvent } from '@testing-library/react';\n   import { WhyReportButton } from './WhyReportButton';\n   \n   describe('WhyReportButton', () => {\n     it('should be disabled when isDisabled is true', () => {\n       render(<WhyReportButton isDisabled={true} sessionId=\"123\" onClick={() => {}} />);\n       expect(screen.getByRole('button')).toBeDisabled();\n     });\n     \n     it('should be enabled when isDisabled is false', () => {\n       render(<WhyReportButton isDisabled={false} sessionId=\"123\" onClick={() => {}} />);\n       expect(screen.getByRole('button')).not.toBeDisabled();\n     });\n     \n     it('should call onClick when clicked', () => {\n       const onClickMock = jest.fn();\n       render(<WhyReportButton isDisabled={false} sessionId=\"123\" onClick={onClickMock} />);\n       fireEvent.click(screen.getByRole('button'));\n       expect(onClickMock).toHaveBeenCalledTimes(1);\n     });\n   });\n   ```\n\n2. Integration Testing:\n   - Test the report page with different states:\n   ```tsx\n   // src/app/session/[id]/report/page.test.tsx\n   import { render, screen, waitFor } from '@testing-library/react';\n   import { useRouter } from 'next/navigation';\n   import ReportPage from './page';\n   import { useReportStatus } from '@/hooks/useReportStatus';\n   \n   // Mock the hooks\n   jest.mock('next/navigation', () => ({\n     useRouter: jest.fn()\n   }));\n   \n   jest.mock('@/hooks/useReportStatus', () => ({\n     useReportStatus: jest.fn()\n   }));\n   \n   describe('ReportPage', () => {\n     const mockRouter = { push: jest.fn() };\n     \n     beforeEach(() => {\n       useRouter.mockReturnValue(mockRouter);\n     });\n     \n     it('should show minimal loading UI for returning users', () => {\n       useReportStatus.mockReturnValue({\n         hasExistingReport: true,\n         isGenerating: true,\n         isComplete: false\n       });\n       \n       render(<ReportPage params={{ id: '123' }} />);\n       \n       expect(screen.getByText(/보고서를 생성하고 있어요/)).toBeInTheDocument();\n       expect(screen.queryByText(/AI가 당신의 대화를 분석하고 있어요/)).not.toBeInTheDocument();\n     });\n     \n     it('should show onboarding experience for first-time users', () => {\n       useReportStatus.mockReturnValue({\n         hasExistingReport: false,\n         isGenerating: true,\n         isComplete: false\n       });\n       \n       render(<ReportPage params={{ id: '123' }} />);\n       \n       expect(screen.getByText(/AI가 당신의 대화를 분석하고 있어요/)).toBeInTheDocument();\n       expect(screen.getByRole('button', { name: /나의 why 보고서/ })).toBeDisabled();\n     });\n     \n     it('should enable the button when generation completes', async () => {\n       useReportStatus.mockReturnValue({\n         hasExistingReport: false,\n         isGenerating: true,\n         isComplete: true\n       });\n       \n       render(<ReportPage params={{ id: '123' }} />);\n       \n       expect(screen.getByRole('button', { name: /나의 why 보고서/ })).not.toBeDisabled();\n     });\n     \n     it('should auto-navigate to why page after first-time generation completes', async () => {\n       useReportStatus.mockReturnValue({\n         hasExistingReport: false,\n         isGenerating: true,\n         isComplete: true\n       });\n       \n       render(<ReportPage params={{ id: '123' }} />);\n       \n       // Simulate onboarding completion\n       await waitFor(() => {\n         expect(mockRouter.push).toHaveBeenCalledWith('/session/123/why');\n       });\n     });\n   });\n   ```\n\n3. End-to-End Testing:\n   - Create Cypress tests to verify the complete user flow:\n   ```javascript\n   // cypress/e2e/report-onboarding.cy.js\n   describe('Report Onboarding Experience', () => {\n     it('should show onboarding for first-time users and auto-navigate', () => {\n       // Mock API responses\n       cy.intercept('GET', '/api/sessions/*/report/status', {\n         exists: false,\n         isGenerating: true,\n         isComplete: false\n       }).as('reportStatus');\n       \n       // Visit the report page\n       cy.visit('/session/test-session-id/report');\n       \n       // Verify onboarding messages appear\n       cy.contains('AI가 당신의 대화를 분석하고 있어요').should('be.visible');\n       \n       // Verify button is disabled\n       cy.contains('button', '나의 why 보고서').should('be.disabled');\n       \n       // Mock completion after some time\n       cy.wait(3000);\n       cy.intercept('GET', '/api/sessions/*/report/status', {\n         exists: false,\n         isGenerating: true,\n         isComplete: true\n       }).as('reportComplete');\n       \n       // Verify auto-navigation to why page\n       cy.url().should('include', '/session/test-session-id/why');\n     });\n     \n     it('should show minimal loading for returning users', () => {\n       // Mock API responses for existing report\n       cy.intercept('GET', '/api/sessions/*/report/status', {\n         exists: true,\n         isGenerating: true,\n         isComplete: false\n       }).as('existingReportStatus');\n       \n       // Visit the report page\n       cy.visit('/session/test-session-id/report');\n       \n       // Verify minimal loading UI\n       cy.contains('보고서를 생성하고 있어요').should('be.visible');\n       \n       // Verify onboarding messages don't appear\n       cy.contains('AI가 당신의 대화를 분석하고 있어요').should('not.exist');\n     });\n   });\n   ```\n\n4. Visual Testing:\n   - Capture screenshots of the onboarding experience at different stages\n   - Compare the visual appearance in both light and dark mode\n   - Verify responsive behavior on different screen sizes\n\n5. Manual Testing Checklist:\n   - Verify first-time user experience shows scripted messages in sequence\n   - Confirm the \"나의 why 보고서\" button is initially disabled\n   - Verify the button enables when generation completes\n   - Test auto-navigation to the why report page\n   - Confirm returning users see minimal loading UI\n   - Verify cascade generation behavior remains intact\n   - Test with slow network conditions to ensure messages display properly\n   - Verify proper error handling if report generation fails",
        "status": "pending",
        "dependencies": [
          8,
          6
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Refine Report Page State Logic and Navigation",
        "description": "Improve the report page state management to distinguish between cached reports and first-time generation, optimize the loading experience, and implement seamless navigation between report states without page transitions.",
        "details": "1. Update the report page state management:\n   ```tsx\n   // In src/app/session/[id]/report/page.tsx\n   import { useReportStatus } from '@/hooks/useReportStatus';\n   \n   const ReportPage = ({ params }) => {\n     const { id } = params;\n     const { hasExistingReports, isGenerating, reportTypes } = useReportStatus(id);\n     \n     // Track which reports exist and which are being generated\n     const hasAllReports = reportTypes.every(type => reportTypes[type].exists);\n     const isAnyReportGenerating = reportTypes.some(type => reportTypes[type].isGenerating);\n     \n     // Only show onboarding when any report is missing and being generated\n     const shouldShowOnboarding = !hasAllReports && isAnyReportGenerating;\n     \n     // Rest of component...\n   }\n   ```\n\n2. Refactor the `useReportStatus` hook to provide more granular state information:\n   ```tsx\n   // In src/hooks/useReportStatus.ts\n   export function useReportStatus(sessionId: string) {\n     const [reportStatus, setReportStatus] = useState({\n       summary: { exists: false, isGenerating: false },\n       why: { exists: false, isGenerating: false },\n       how: { exists: false, isGenerating: false }\n     });\n     \n     const hasExistingReports = Object.values(reportStatus).some(status => status.exists);\n     const isGenerating = Object.values(reportStatus).some(status => status.isGenerating);\n     \n     useEffect(() => {\n       // Check cache/API for existing reports\n       const checkReportStatus = async () => {\n         try {\n           const reports = await fetchReportStatus(sessionId);\n           setReportStatus(reports);\n         } catch (error) {\n           console.error('Failed to fetch report status:', error);\n         }\n       };\n       \n       checkReportStatus();\n       \n       // Set up polling or websocket for real-time updates\n       // ...\n     }, [sessionId]);\n     \n     return {\n       reportTypes: reportStatus,\n       hasExistingReports,\n       isGenerating\n     };\n   }\n   ```\n\n3. Implement a view state manager to handle transitions between loading and report views:\n   ```tsx\n   // In src/app/session/[id]/report/page.tsx\n   \n   const ReportPage = ({ params }) => {\n     // ... previous code\n     \n     const [activeView, setActiveView] = useState('loading'); // 'loading', 'summary', 'why', 'how'\n     \n     // Auto-transition to report view when reports are ready\n     useEffect(() => {\n       if (hasAllReports && activeView === 'loading') {\n         setActiveView('summary'); // Default to summary view\n       }\n       \n       // If a specific report becomes available while in loading view\n       if (activeView === 'loading') {\n         for (const type of ['summary', 'why', 'how']) {\n           if (reportTypes[type].exists && !reportTypes[type].isGenerating) {\n             setActiveView(type);\n             break;\n           }\n         }\n       }\n     }, [reportTypes, hasAllReports, activeView]);\n     \n     // Allow manual switching between report types when available\n     const switchToReport = (reportType) => {\n       if (reportTypes[reportType].exists) {\n         setActiveView(reportType);\n       }\n     };\n     \n     return (\n       <div className=\"report-page\">\n         {activeView === 'loading' && shouldShowOnboarding ? (\n           <OnboardingExperience reportStatus={reportTypes} />\n         ) : (\n           <ReportViewer \n             reportType={activeView} \n             reportStatus={reportTypes}\n             onSwitchReport={switchToReport}\n           />\n         )}\n       </div>\n     );\n   }\n   ```\n\n4. Remove the gate UI that previously prevented users from accessing reports during generation:\n   - Remove any conditional rendering that hides report tabs or navigation\n   - Update the ReportViewer component to handle partially available reports:\n   ```tsx\n   // In src/components/report/ReportViewer.tsx\n   \n   const ReportViewer = ({ reportType, reportStatus, onSwitchReport }) => {\n     return (\n       <div className=\"report-viewer\">\n         <ReportNavigation \n           reportStatus={reportStatus}\n           activeReport={reportType}\n           onSwitchReport={onSwitchReport}\n         />\n         \n         <div className=\"report-content\">\n           {reportStatus[reportType].exists ? (\n             <ReportContent type={reportType} />\n           ) : reportStatus[reportType].isGenerating ? (\n             <ReportGeneratingPlaceholder type={reportType} />\n           ) : (\n             <ReportErrorState type={reportType} />\n           )}\n         </div>\n       </div>\n     );\n   }\n   ```\n\n5. Update the report navigation to visually indicate report availability:\n   ```tsx\n   // In src/components/report/ReportNavigation.tsx\n   \n   const ReportNavigation = ({ reportStatus, activeReport, onSwitchReport }) => {\n     return (\n       <nav className=\"report-tabs\">\n         {Object.entries(reportStatus).map(([type, status]) => (\n           <button\n             key={type}\n             className={`report-tab ${activeReport === type ? 'active' : ''} ${status.exists ? 'available' : ''} ${status.isGenerating ? 'generating' : ''}`}\n             onClick={() => onSwitchReport(type)}\n             disabled={!status.exists && !status.isGenerating}\n           >\n             {type.charAt(0).toUpperCase() + type.slice(1)}\n             {status.isGenerating && <LoadingIndicator size=\"small\" />}\n           </button>\n         ))}\n       </nav>\n     );\n   }\n   ```\n\n6. Implement caching for report data to improve performance:\n   ```tsx\n   // In src/services/reportService.ts\n   \n   const reportCache = new Map();\n   \n   export async function fetchReport(sessionId, reportType) {\n     const cacheKey = `${sessionId}-${reportType}`;\n     \n     // Return cached data if available\n     if (reportCache.has(cacheKey)) {\n       return reportCache.get(cacheKey);\n     }\n     \n     // Fetch from API\n     try {\n       const response = await fetch(`/api/sessions/${sessionId}/reports/${reportType}`);\n       if (!response.ok) throw new Error('Failed to fetch report');\n       \n       const reportData = await response.json();\n       \n       // Cache the result\n       reportCache.set(cacheKey, reportData);\n       \n       return reportData;\n     } catch (error) {\n       console.error(`Error fetching ${reportType} report:`, error);\n       throw error;\n     }\n   }\n   ```",
        "testStrategy": "1. Unit Testing:\n   - Test the `useReportStatus` hook with various scenarios:\n   ```tsx\n   // src/hooks/useReportStatus.test.tsx\n   import { renderHook, act } from '@testing-library/react-hooks';\n   import { useReportStatus } from './useReportStatus';\n   import { fetchReportStatus } from '../services/reportService';\n   \n   // Mock the API service\n   jest.mock('../services/reportService');\n   \n   describe('useReportStatus hook', () => {\n     test('should return correct status when all reports exist', async () => {\n       fetchReportStatus.mockResolvedValue({\n         summary: { exists: true, isGenerating: false },\n         why: { exists: true, isGenerating: false },\n         how: { exists: true, isGenerating: false }\n       });\n       \n       const { result, waitForNextUpdate } = renderHook(() => useReportStatus('test-session-id'));\n       \n       await waitForNextUpdate();\n       \n       expect(result.current.hasExistingReports).toBe(true);\n       expect(result.current.isGenerating).toBe(false);\n     });\n     \n     test('should return correct status when some reports are generating', async () => {\n       fetchReportStatus.mockResolvedValue({\n         summary: { exists: true, isGenerating: false },\n         why: { exists: false, isGenerating: true },\n         how: { exists: false, isGenerating: false }\n       });\n       \n       const { result, waitForNextUpdate } = renderHook(() => useReportStatus('test-session-id'));\n       \n       await waitForNextUpdate();\n       \n       expect(result.current.hasExistingReports).toBe(true);\n       expect(result.current.isGenerating).toBe(true);\n     });\n   });\n   ```\n\n2. Integration Testing:\n   - Test the ReportPage component with different report states:\n   ```tsx\n   // src/app/session/[id]/report/page.test.tsx\n   import { render, screen, waitFor } from '@testing-library/react';\n   import userEvent from '@testing-library/user-event';\n   import ReportPage from './page';\n   import { useReportStatus } from '@/hooks/useReportStatus';\n   \n   // Mock the hook\n   jest.mock('@/hooks/useReportStatus');\n   \n   describe('ReportPage', () => {\n     test('shows onboarding when reports are generating for the first time', () => {\n       useReportStatus.mockReturnValue({\n         reportTypes: {\n           summary: { exists: false, isGenerating: true },\n           why: { exists: false, isGenerating: true },\n           how: { exists: false, isGenerating: false }\n         },\n         hasExistingReports: false,\n         isGenerating: true\n       });\n       \n       render(<ReportPage params={{ id: 'test-id' }} />);\n       \n       expect(screen.getByTestId('onboarding-experience')).toBeInTheDocument();\n       expect(screen.queryByTestId('report-viewer')).not.toBeInTheDocument();\n     });\n     \n     test('shows report viewer when some reports exist', () => {\n       useReportStatus.mockReturnValue({\n         reportTypes: {\n           summary: { exists: true, isGenerating: false },\n           why: { exists: false, isGenerating: true },\n           how: { exists: false, isGenerating: false }\n         },\n         hasExistingReports: true,\n         isGenerating: true\n       });\n       \n       render(<ReportPage params={{ id: 'test-id' }} />);\n       \n       expect(screen.queryByTestId('onboarding-experience')).not.toBeInTheDocument();\n       expect(screen.getByTestId('report-viewer')).toBeInTheDocument();\n     });\n     \n     test('allows switching between available reports', async () => {\n       useReportStatus.mockReturnValue({\n         reportTypes: {\n           summary: { exists: true, isGenerating: false },\n           why: { exists: true, isGenerating: false },\n           how: { exists: false, isGenerating: true }\n         },\n         hasExistingReports: true,\n         isGenerating: true\n       });\n       \n       render(<ReportPage params={{ id: 'test-id' }} />);\n       \n       // Should start with summary view\n       expect(screen.getByTestId('summary-report')).toBeInTheDocument();\n       \n       // Switch to why report\n       userEvent.click(screen.getByRole('button', { name: /why/i }));\n       \n       await waitFor(() => {\n         expect(screen.getByTestId('why-report')).toBeInTheDocument();\n         expect(screen.queryByTestId('summary-report')).not.toBeInTheDocument();\n       });\n     });\n   });\n   ```\n\n3. End-to-End Testing:\n   - Create Cypress tests to verify the full report generation and viewing flow:\n   ```javascript\n   // cypress/e2e/report-flow.cy.js\n   describe('Report Generation and Viewing Flow', () => {\n     beforeEach(() => {\n       // Set up a test session\n       cy.createTestSession().then(sessionId => {\n         cy.visit(`/session/${sessionId}/report`);\n       });\n     });\n     \n     it('should show onboarding during first-time generation and transition to report view', () => {\n       // Mock API to simulate report generation in progress\n       cy.intercept('GET', '/api/sessions/*/reports/status', {\n         summary: { exists: false, isGenerating: true },\n         why: { exists: false, isGenerating: true },\n         how: { exists: false, isGenerating: false }\n       }).as('initialStatus');\n       \n       // Verify onboarding is shown\n       cy.wait('@initialStatus');\n       cy.get('[data-testid=\"onboarding-experience\"]').should('be.visible');\n       \n       // Mock API to simulate summary report becoming available\n       cy.intercept('GET', '/api/sessions/*/reports/status', {\n         summary: { exists: true, isGenerating: false },\n         why: { exists: false, isGenerating: true },\n         how: { exists: false, isGenerating: false }\n       }).as('updatedStatus');\n       \n       // Verify transition to report view\n       cy.wait('@updatedStatus');\n       cy.get('[data-testid=\"report-viewer\"]').should('be.visible');\n       cy.get('[data-testid=\"summary-report\"]').should('be.visible');\n       \n       // Verify navigation shows correct states\n       cy.get('[data-testid=\"report-tab-summary\"]').should('have.class', 'available');\n       cy.get('[data-testid=\"report-tab-why\"]').should('have.class', 'generating');\n       cy.get('[data-testid=\"report-tab-how\"]').should('be.disabled');\n     });\n     \n     it('should allow switching between available reports without page reload', () => {\n       // Mock API to simulate multiple reports available\n       cy.intercept('GET', '/api/sessions/*/reports/status', {\n         summary: { exists: true, isGenerating: false },\n         why: { exists: true, isGenerating: false },\n         how: { exists: false, isGenerating: true }\n       }).as('reportsStatus');\n       \n       cy.wait('@reportsStatus');\n       \n       // Verify can switch between summary and why reports\n       cy.get('[data-testid=\"report-tab-summary\"]').click();\n       cy.get('[data-testid=\"summary-report\"]').should('be.visible');\n       \n       cy.get('[data-testid=\"report-tab-why\"]').click();\n       cy.get('[data-testid=\"why-report\"]').should('be.visible');\n       cy.get('[data-testid=\"summary-report\"]').should('not.exist');\n       \n       // Verify URL doesn't change during tab switching\n       cy.url().should('include', '/report');\n       cy.url().should('not.include', '/why');\n     });\n   });\n   ```\n\n4. Visual Testing:\n   - Create visual regression tests to verify the UI states:\n   ```javascript\n   // cypress/e2e/report-visual.cy.js\n   describe('Report Page Visual States', () => {\n     it('should display loading states correctly', () => {\n       // Mock API for loading state\n       cy.intercept('GET', '/api/sessions/*/reports/status', {\n         summary: { exists: false, isGenerating: true },\n         why: { exists: false, isGenerating: true },\n         how: { exists: false, isGenerating: false }\n       });\n       \n       cy.visit('/session/test-id/report');\n       cy.get('[data-testid=\"onboarding-experience\"]').should('be.visible');\n       cy.matchImageSnapshot('report-loading-state');\n     });\n     \n     it('should display partial report availability correctly', () => {\n       // Mock API for partial availability\n       cy.intercept('GET', '/api/sessions/*/reports/status', {\n         summary: { exists: true, isGenerating: false },\n         why: { exists: false, isGenerating: true },\n         how: { exists: false, isGenerating: false }\n       });\n       \n       cy.visit('/session/test-id/report');\n       cy.get('[data-testid=\"report-viewer\"]').should('be.visible');\n       cy.matchImageSnapshot('report-partial-availability');\n     });\n     \n     it('should display all reports available correctly', () => {\n       // Mock API for all reports available\n       cy.intercept('GET', '/api/sessions/*/reports/status', {\n         summary: { exists: true, isGenerating: false },\n         why: { exists: true, isGenerating: false },\n         how: { exists: true, isGenerating: false }\n       });\n       \n       cy.visit('/session/test-id/report');\n       cy.get('[data-testid=\"report-viewer\"]').should('be.visible');\n       cy.matchImageSnapshot('report-all-available');\n     });\n   });\n   ```",
        "status": "pending",
        "dependencies": [
          11,
          8
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Navigation Improvements and Report Loading UI Enhancements",
        "description": "Enhance navigation flows between home and reports, implement direct routing to specific report types, enable conditional report button activation, and add typewriter effect for script messages.",
        "details": "1. Update navigation flow from Home to Reports:\n```tsx\n// In src/app/page.tsx or relevant home component\nimport { useRouter } from 'next/navigation';\nimport { useReportStatus } from '@/hooks/useReportStatus';\n\nconst HomePage = () => {\n  const router = useRouter();\n  const { sessions } = useSessions(); // Assume this hook fetches user sessions\n  \n  const handleReportClick = (sessionId) => {\n    router.push(`/session/${sessionId}/report?skipOnboarding=true`);\n  };\n  \n  return (\n    // Existing home page code\n    {sessions.map(session => (\n      <SessionCard \n        key={session.id}\n        session={session}\n        onReportClick={() => handleReportClick(session.id)}\n      />\n    ))}\n  );\n};\n```\n\n2. Implement direct routing to report without onboarding:\n```tsx\n// In src/app/session/[id]/report/page.tsx\nimport { useSearchParams } from 'next/navigation';\n\nconst ReportPage = ({ params }) => {\n  const { id } = params;\n  const searchParams = useSearchParams();\n  const skipOnboarding = searchParams.get('skipOnboarding') === 'true';\n  const { hasExistingReports, isGenerating, reportTypes } = useReportStatus(id);\n  \n  // Skip onboarding if explicitly requested via URL param AND reports exist\n  const shouldShowOnboarding = !skipOnboarding && (!hasExistingReports || isFirstTimeGeneration);\n  \n  return (\n    <div>\n      {shouldShowOnboarding ? (\n        <OnboardingMessages sessionId={id} />\n      ) : (\n        <ReportViewer sessionId={id} />\n      )}\n    </div>\n  );\n};\n```\n\n3. Update routing after script completion:\n```tsx\n// In src/components/report/OnboardingMessages.tsx\nimport { useRouter } from 'next/navigation';\n\nconst OnboardingMessages = ({ sessionId }) => {\n  const router = useRouter();\n  const { isComplete } = useScriptProgress();\n  \n  useEffect(() => {\n    if (isComplete) {\n      // Navigate to the why report after scripts finish\n      router.push(`/session/${sessionId}/why`);\n    }\n  }, [isComplete, sessionId, router]);\n  \n  // Rest of component...\n};\n```\n\n4. Implement conditional report button activation:\n```tsx\n// In src/components/report/ReportControls.tsx\nimport { useReportStatus } from '@/hooks/useReportStatus';\n\nconst ReportControls = ({ sessionId }) => {\n  const { reportTypes, isGenerating } = useReportStatus(sessionId);\n  \n  // Only enable the report button when all reports are ready\n  const areAllReportsReady = Object.values(reportTypes).every(report => report.exists && !report.isGenerating);\n  \n  return (\n    <div className=\"report-controls\">\n      <Button \n        onClick={() => handleViewReports()}\n        disabled={!areAllReportsReady}\n      >\n        {isGenerating ? 'Generating Reports...' : 'View Reports'}\n      </Button>\n      {!areAllReportsReady && (\n        <LoadingIndicator \n          progress={calculateProgress(reportTypes)} \n        />\n      )}\n    </div>\n  );\n};\n```\n\n5. Implement typewriter effect for script messages:\n```tsx\n// In src/components/ui/TypewriterText.tsx\nimport { useState, useEffect } from 'react';\n\nexport const TypewriterText = ({ text, speed = 30, onComplete }) => {\n  const [displayedText, setDisplayedText] = useState('');\n  const [currentIndex, setCurrentIndex] = useState(0);\n  \n  useEffect(() => {\n    if (currentIndex < text.length) {\n      const timer = setTimeout(() => {\n        setDisplayedText(prev => prev + text[currentIndex]);\n        setCurrentIndex(prev => prev + 1);\n      }, speed);\n      \n      return () => clearTimeout(timer);\n    } else if (onComplete) {\n      onComplete();\n    }\n  }, [currentIndex, text, speed, onComplete]);\n  \n  return <span>{displayedText}</span>;\n};\n\n// Usage in OnboardingMessages.tsx\nconst OnboardingMessages = ({ sessionId }) => {\n  const [currentMessageIndex, setCurrentMessageIndex] = useState(0);\n  const messages = [\n    \"Analyzing your conversation...\",\n    \"Identifying key patterns...\",\n    \"Generating insights...\",\n    // More messages\n  ];\n  \n  const handleMessageComplete = () => {\n    if (currentMessageIndex < messages.length - 1) {\n      setCurrentMessageIndex(prev => prev + 1);\n    }\n  };\n  \n  return (\n    <div className=\"onboarding-messages\">\n      <TypewriterText \n        text={messages[currentMessageIndex]} \n        speed={40}\n        onComplete={handleMessageComplete}\n      />\n    </div>\n  );\n};\n```\n\n6. Update the navigation state management to track report generation status:\n```tsx\n// In src/hooks/useReportStatus.ts\nimport { useState, useEffect } from 'react';\nimport { fetchReportStatus } from '@/services/reportService';\n\nexport const useReportStatus = (sessionId) => {\n  const [status, setStatus] = useState({\n    hasExistingReports: false,\n    isGenerating: false,\n    reportTypes: {\n      why: { exists: false, isGenerating: false },\n      what: { exists: false, isGenerating: false },\n      how: { exists: false, isGenerating: false }\n    }\n  });\n  \n  useEffect(() => {\n    const checkStatus = async () => {\n      const reportStatus = await fetchReportStatus(sessionId);\n      setStatus(reportStatus);\n    };\n    \n    checkStatus();\n    \n    // Poll for updates if reports are generating\n    if (status.isGenerating) {\n      const interval = setInterval(checkStatus, 3000);\n      return () => clearInterval(interval);\n    }\n  }, [sessionId, status.isGenerating]);\n  \n  return status;\n};\n```",
        "testStrategy": "1. Unit Testing:\n   - Test the TypewriterText component:\n   ```tsx\n   // src/components/ui/TypewriterText.test.tsx\n   import { render, screen, act } from '@testing-library/react';\n   import { TypewriterText } from './TypewriterText';\n   \n   jest.useFakeTimers();\n   \n   describe('TypewriterText', () => {\n     it('should render text character by character', () => {\n       const mockOnComplete = jest.fn();\n       render(<TypewriterText text=\"Hello\" speed={50} onComplete={mockOnComplete} />);\n       \n       expect(screen.getByText('')).toBeInTheDocument();\n       \n       act(() => {\n         jest.advanceTimersByTime(50);\n       });\n       expect(screen.getByText('H')).toBeInTheDocument();\n       \n       act(() => {\n         jest.advanceTimersByTime(50);\n       });\n       expect(screen.getByText('He')).toBeInTheDocument();\n       \n       // Complete the text\n       act(() => {\n         jest.advanceTimersByTime(150);\n       });\n       expect(screen.getByText('Hello')).toBeInTheDocument();\n       expect(mockOnComplete).toHaveBeenCalled();\n     });\n   });\n   ```\n\n2. Integration Testing:\n   - Test the navigation flow from home to reports:\n   ```tsx\n   // src/tests/navigation.test.tsx\n   import { render, screen, fireEvent } from '@testing-library/react';\n   import { HomePage } from '../app/page';\n   import { mockRouter } from '../test-utils/mockRouter';\n   \n   jest.mock('next/navigation', () => ({\n     useRouter: () => mockRouter\n   }));\n   \n   describe('Navigation Flow', () => {\n     it('should navigate to report page with skipOnboarding param when clicking on existing report', () => {\n       render(<HomePage />);\n       \n       fireEvent.click(screen.getByText('View Report'));\n       \n       expect(mockRouter.push).toHaveBeenCalledWith(\n         expect.stringContaining('/session/') && \n         expect.stringContaining('skipOnboarding=true')\n       );\n     });\n   });\n   ```\n   \n   - Test the conditional report button activation:\n   ```tsx\n   // src/components/report/ReportControls.test.tsx\n   import { render, screen } from '@testing-library/react';\n   import { ReportControls } from './ReportControls';\n   import { useReportStatus } from '@/hooks/useReportStatus';\n   \n   jest.mock('@/hooks/useReportStatus');\n   \n   describe('ReportControls', () => {\n     it('should disable button when reports are still generating', () => {\n       (useReportStatus as jest.Mock).mockReturnValue({\n         reportTypes: {\n           why: { exists: true, isGenerating: false },\n           what: { exists: false, isGenerating: true },\n           how: { exists: false, isGenerating: true }\n         },\n         isGenerating: true\n       });\n       \n       render(<ReportControls sessionId=\"123\" />);\n       \n       expect(screen.getByRole('button', { name: /generating reports/i })).toBeDisabled();\n     });\n     \n     it('should enable button when all reports are ready', () => {\n       (useReportStatus as jest.Mock).mockReturnValue({\n         reportTypes: {\n           why: { exists: true, isGenerating: false },\n           what: { exists: true, isGenerating: false },\n           how: { exists: true, isGenerating: false }\n         },\n         isGenerating: false\n       });\n       \n       render(<ReportControls sessionId=\"123\" />);\n       \n       expect(screen.getByRole('button', { name: /view reports/i })).toBeEnabled();\n     });\n   });\n   ```\n\n3. End-to-End Testing:\n   - Test the complete flow from home to report viewing:\n   ```typescript\n   // cypress/e2e/report-navigation.cy.ts\n   describe('Report Navigation', () => {\n     it('should navigate directly to report from home page', () => {\n       // Setup: Create a session with existing reports\n       cy.setupSessionWithReports('test-session');\n       \n       // Visit home page\n       cy.visit('/');\n       \n       // Click on the session card's report button\n       cy.contains('Test Session').parent().find('[data-testid=\"view-report-btn\"]').click();\n       \n       // Should navigate directly to report page without onboarding\n       cy.url().should('include', '/session/test-session/report');\n       cy.url().should('include', 'skipOnboarding=true');\n       \n       // Should show report content immediately, not onboarding\n       cy.get('[data-testid=\"report-content\"]').should('be.visible');\n       cy.get('[data-testid=\"onboarding-messages\"]').should('not.exist');\n     });\n     \n     it('should navigate to why report after script completion', () => {\n       // Visit report page for first-time generation\n       cy.visit('/session/new-session/report');\n       \n       // Should show onboarding messages with typewriter effect\n       cy.get('[data-testid=\"onboarding-messages\"]').should('be.visible');\n       \n       // Fast-forward through all messages\n       cy.window().then((win) => {\n         win.completeAllMessages(); // Helper function to be added to test environment\n       });\n       \n       // Should automatically navigate to why report\n       cy.url().should('include', '/session/new-session/why');\n     });\n   });\n   ```\n\n4. Visual Testing:\n   - Verify the typewriter effect appears smooth and readable\n   - Ensure loading indicators and disabled states are visually distinct\n   - Check that navigation transitions feel seamless to users",
        "status": "pending",
        "dependencies": [
          11,
          12,
          8
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Prologue Report Generation",
        "description": "Extend the GET /api/session/[id]/report endpoint to support a new 'prologue' report type using the provided JSON prompt schema, extracting USER_NAME, transcript, and WHY_REFINED data with BAN_TEMPLATES filter, and storing the JSON in the reports table.",
        "details": "1. Update the API endpoint to handle the new report type:\n```typescript\n// In src/app/api/session/[id]/report/route.ts\nexport async function GET(\n  request: Request,\n  { params }: { params: { id: string } }\n) {\n  const { searchParams } = new URL(request.url);\n  const type = searchParams.get('type') || 'why';\n  const sessionId = params.id;\n\n  // Validate session exists\n  const session = await db.session.findUnique({\n    where: { id: sessionId },\n    include: { user: true }\n  });\n\n  if (!session) {\n    return new Response(JSON.stringify({ error: 'Session not found' }), {\n      status: 404,\n    });\n  }\n\n  // Check if report already exists\n  const existingReport = await db.report.findFirst({\n    where: {\n      sessionId,\n      type,\n    },\n  });\n\n  if (existingReport) {\n    return new Response(JSON.stringify(existingReport), {\n      status: 200,\n    });\n  }\n\n  // Handle different report types\n  if (type === 'prologue') {\n    return handlePrologueReport(session);\n  } else if (type === 'why') {\n    return handleWhyReport(session);\n  } else {\n    return new Response(JSON.stringify({ error: 'Invalid report type' }), {\n      status: 400,\n    });\n  }\n}\n\n// Add new function to handle prologue report generation\nasync function handlePrologueReport(session) {\n  try {\n    // Get transcript data\n    const messages = await db.message.findMany({\n      where: { sessionId: session.id },\n      orderBy: { createdAt: 'asc' },\n    });\n    \n    // Extract transcript text\n    const transcript = messages.map(msg => ({\n      role: msg.role,\n      content: msg.content\n    }));\n    \n    // Get WHY_REFINED data if it exists\n    const whyReport = await db.report.findFirst({\n      where: {\n        sessionId: session.id,\n        type: 'why',\n      },\n    });\n    \n    const whyRefined = whyReport?.content?.WHY_REFINED || null;\n    \n    // Construct prologue prompt with required fields\n    const prologuePrompt = {\n      USER_NAME: session.user.name || 'User',\n      transcript,\n      WHY_REFINED: whyRefined,\n      BAN_TEMPLATES: true\n    };\n    \n    // Call AI service to generate prologue report\n    const aiService = new AIService();\n    const prologueResponse = await aiService.generatePrologueReport(prologuePrompt);\n    \n    // Store the report in the database\n    const report = await db.report.create({\n      data: {\n        sessionId: session.id,\n        type: 'prologue',\n        content: prologueResponse,\n      },\n    });\n    \n    return new Response(JSON.stringify(report), {\n      status: 200,\n    });\n  } catch (error) {\n    console.error('Error generating prologue report:', error);\n    return new Response(JSON.stringify({ error: 'Failed to generate prologue report' }), {\n      status: 500,\n    });\n  }\n}\n```\n\n2. Create or update the AI service to handle prologue report generation:\n```typescript\n// In src/services/ai.service.ts\nexport class AIService {\n  // Existing methods...\n  \n  async generatePrologueReport(prompt: {\n    USER_NAME: string;\n    transcript: Array<{role: string, content: string}>;\n    WHY_REFINED: string | null;\n    BAN_TEMPLATES: boolean;\n  }) {\n    try {\n      const response = await fetch(`${process.env.AI_SERVICE_URL}/generate-prologue`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${process.env.AI_SERVICE_API_KEY}`\n        },\n        body: JSON.stringify(prompt)\n      });\n      \n      if (!response.ok) {\n        throw new Error(`AI service responded with status: ${response.status}`);\n      }\n      \n      return await response.json();\n    } catch (error) {\n      console.error('Error calling AI service for prologue generation:', error);\n      throw error;\n    }\n  }\n}\n```\n\n3. Update the frontend to support the new report type:\n```typescript\n// In src/hooks/useReportStatus.ts\nexport function useReportStatus(sessionId: string) {\n  const [reportStatus, setReportStatus] = useState({\n    why: { exists: false, generating: false },\n    prologue: { exists: false, generating: false },\n    // other report types...\n  });\n  \n  // Rest of the hook implementation...\n}\n\n// In src/app/session/[id]/report/page.tsx\n// Add UI elements to display and generate prologue reports\n```\n\n4. Update the database schema if needed:\n```prisma\n// In prisma/schema.prisma\n// Ensure the report model supports the new type\nmodel Report {\n  id        String   @id @default(cuid())\n  sessionId String\n  type      String   // Now supports 'why', 'prologue', etc.\n  content   Json\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n  \n  session   Session  @relation(fields: [sessionId], references: [id])\n  \n  @@index([sessionId, type])\n}\n```",
        "testStrategy": "1. Unit Testing:\n   - Test the API endpoint with different report types:\n   ```typescript\n   // In src/app/api/session/[id]/report/route.test.ts\n   \n   describe('GET /api/session/[id]/report', () => {\n     beforeEach(() => {\n       // Mock database and AI service\n     });\n     \n     it('should return existing prologue report if it exists', async () => {\n       // Mock existing report in database\n       mockDb.report.findFirst.mockResolvedValue({\n         id: 'report1',\n         type: 'prologue',\n         content: { /* mock content */ },\n       });\n       \n       const response = await GET(\n         new Request('http://localhost/api/session/123/report?type=prologue'),\n         { params: { id: '123' } }\n       );\n       \n       expect(response.status).toBe(200);\n       const data = await response.json();\n       expect(data.type).toBe('prologue');\n     });\n     \n     it('should generate a new prologue report if none exists', async () => {\n       // Mock no existing report\n       mockDb.report.findFirst.mockResolvedValue(null);\n       \n       // Mock session and user data\n       mockDb.session.findUnique.mockResolvedValue({\n         id: '123',\n         user: { name: 'Test User' },\n       });\n       \n       // Mock messages for transcript\n       mockDb.message.findMany.mockResolvedValue([\n         { role: 'user', content: 'Hello' },\n         { role: 'assistant', content: 'Hi there' },\n       ]);\n       \n       // Mock AI service response\n       mockAIService.generatePrologueReport.mockResolvedValue({\n         /* mock prologue content */\n       });\n       \n       const response = await GET(\n         new Request('http://localhost/api/session/123/report?type=prologue'),\n         { params: { id: '123' } }\n       );\n       \n       expect(response.status).toBe(200);\n       expect(mockDb.report.create).toHaveBeenCalledWith({\n         data: {\n           sessionId: '123',\n           type: 'prologue',\n           content: expect.any(Object),\n         },\n       });\n     });\n     \n     it('should handle errors during prologue generation', async () => {\n       // Mock no existing report\n       mockDb.report.findFirst.mockResolvedValue(null);\n       \n       // Mock session data\n       mockDb.session.findUnique.mockResolvedValue({\n         id: '123',\n         user: { name: 'Test User' },\n       });\n       \n       // Mock AI service error\n       mockAIService.generatePrologueReport.mockRejectedValue(new Error('AI service error'));\n       \n       const response = await GET(\n         new Request('http://localhost/api/session/123/report?type=prologue'),\n         { params: { id: '123' } }\n       );\n       \n       expect(response.status).toBe(500);\n       const data = await response.json();\n       expect(data.error).toBeDefined();\n     });\n   });\n   ```\n\n2. Integration Testing:\n   - Test the complete flow from API to database:\n   ```typescript\n   // In tests/integration/prologueReport.test.ts\n   \n   describe('Prologue Report Generation', () => {\n     it('should generate and store a prologue report', async () => {\n       // Create a test session with messages\n       const session = await createTestSession();\n       \n       // Generate a why report first (if needed as dependency)\n       await fetch(`/api/session/${session.id}/report?type=why`);\n       \n       // Generate prologue report\n       const response = await fetch(`/api/session/${session.id}/report?type=prologue`);\n       expect(response.status).toBe(200);\n       \n       // Verify report was stored in database\n       const storedReport = await db.report.findFirst({\n         where: {\n           sessionId: session.id,\n           type: 'prologue',\n         },\n       });\n       \n       expect(storedReport).not.toBeNull();\n       expect(storedReport.content).toHaveProperty('USER_NAME');\n     });\n   });\n   ```\n\n3. Frontend Testing:\n   - Test the UI components that display prologue reports:\n   ```typescript\n   // In src/components/report/PrologueReport.test.tsx\n   \n   import { render, screen } from '@testing-library/react';\n   import { PrologueReport } from './PrologueReport';\n   \n   describe('PrologueReport component', () => {\n     it('should render prologue report content correctly', () => {\n       const mockReport = {\n         // Mock prologue report data\n       };\n       \n       render(<PrologueReport report={mockReport} />);\n       \n       // Assert that the component renders the expected content\n       expect(screen.getByText(/some expected text/i)).toBeInTheDocument();\n     });\n   });\n   ```\n\n4. End-to-End Testing:\n   - Create a Cypress test that simulates a user generating a prologue report:\n   ```typescript\n   // In cypress/e2e/prologueReport.cy.ts\n   \n   describe('Prologue Report Generation', () => {\n     beforeEach(() => {\n       // Log in and navigate to a session\n       cy.login();\n       cy.visit('/sessions');\n       cy.get('[data-testid=\"session-item\"]').first().click();\n     });\n     \n     it('should generate a prologue report', () => {\n       // Navigate to report page\n       cy.get('[data-testid=\"generate-report-button\"]').click();\n       \n       // Select prologue report type if needed\n       cy.get('[data-testid=\"report-type-prologue\"]').click();\n       \n       // Wait for report generation\n       cy.get('[data-testid=\"loading-indicator\"]', { timeout: 10000 }).should('exist');\n       cy.get('[data-testid=\"loading-indicator\"]', { timeout: 30000 }).should('not.exist');\n       \n       // Verify report is displayed\n       cy.get('[data-testid=\"prologue-report\"]').should('be.visible');\n     });\n   });\n   ```",
        "status": "pending",
        "dependencies": [
          8,
          11,
          12
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Create Prologue UI Page with Report Integration",
        "description": "Create the /app/session/[id]/prologue/page.tsx component to render the Prologue UI with interactive elements and integrate it with the API endpoints for fetching and saving prologue data.",
        "details": "1. Create the prologue page component:\n```tsx\n// src/app/session/[id]/prologue/page.tsx\n'use client';\n\nimport { useState, useEffect } from 'react';\nimport { useParams } from 'next/navigation';\nimport Container from '@/components/layout/Container';\nimport Section from '@/components/layout/Section';\nimport Button from '@/components/ui/Button';\nimport { CopyToClipboard } from '@/components/ui/CopyToClipboard';\n\nexport default function ProloguePage() {\n  const { id } = useParams();\n  const [prologueData, setPrologueData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [oneLine, setOneLine] = useState('');\n  const [saving, setSaving] = useState(false);\n  const [saved, setSaved] = useState(false);\n\n  // Fetch prologue data\n  useEffect(() => {\n    async function fetchPrologueData() {\n      try {\n        setLoading(true);\n        const response = await fetch(`/api/session/${id}/report?type=prologue`);\n        if (!response.ok) {\n          throw new Error('Failed to fetch prologue data');\n        }\n        const data = await response.json();\n        setPrologueData(data);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    fetchPrologueData();\n  }, [id]);\n\n  // Handle one-line input submission\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    if (!oneLine.trim()) return;\n\n    try {\n      setSaving(true);\n      const response = await fetch(`/api/session/${id}/prologue`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ one_line: oneLine }),\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to save prologue data');\n      }\n\n      setSaved(true);\n      setTimeout(() => setSaved(false), 3000);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setSaving(false);\n    }\n  };\n\n  if (loading) {\n    return (\n      <Container>\n        <Section>\n          <div className=\"loading-indicator\">Loading prologue data...</div>\n        </Section>\n      </Container>\n    );\n  }\n\n  if (error) {\n    return (\n      <Container>\n        <Section>\n          <div className=\"error-message\">Error: {error}</div>\n        </Section>\n      </Container>\n    );\n  }\n\n  return (\n    <Container>\n      <Section>\n        <h1>Prologue</h1>\n        \n        {/* Why ON/OFF Switch Section */}\n        <div className=\"prologue-section\">\n          <h2>Why ON/OFF Switch</h2>\n          <p>{prologueData.why_switch_explanation}</p>\n          <div className=\"switch-container\">\n            {/* Toggle switch implementation */}\n            <label className=\"switch\">\n              <input type=\"checkbox\" />\n              <span className=\"slider round\"></span>\n            </label>\n            <span>Toggle ON/OFF</span>\n          </div>\n        </div>\n        \n        {/* Alternatives Section */}\n        <div className=\"prologue-section\">\n          <h2>Alternatives</h2>\n          <ul>\n            {prologueData.alternatives.map((alt, index) => (\n              <li key={index}>{alt}</li>\n            ))}\n          </ul>\n        </div>\n        \n        {/* Narrative Section */}\n        <div className=\"prologue-section\">\n          <h2>Narrative</h2>\n          <p>{prologueData.narrative}</p>\n          <CopyToClipboard text={prologueData.narrative} />\n        </div>\n        \n        {/* Reflection Questions */}\n        <div className=\"prologue-section\">\n          <h2>Reflection Questions</h2>\n          <ol>\n            {prologueData.reflection_questions.slice(0, 3).map((question, index) => (\n              <li key={index}>{question}</li>\n            ))}\n          </ol>\n        </div>\n        \n        {/* One-line Input */}\n        <div className=\"prologue-section\">\n          <h2>Your One-Line Summary</h2>\n          <form onSubmit={handleSubmit}>\n            <div className=\"input-group\">\n              <input\n                type=\"text\"\n                value={oneLine}\n                onChange={(e) => setOneLine(e.target.value)}\n                placeholder=\"Enter your one-line summary...\"\n                className=\"one-line-input\"\n                aria-label=\"One-line summary\"\n              />\n              <Button \n                type=\"submit\" \n                disabled={saving || !oneLine.trim()}\n                aria-busy={saving}\n              >\n                {saving ? 'Saving...' : 'Enter'}\n              </Button>\n            </div>\n          </form>\n          {saved && <p className=\"success-message\">Successfully saved!</p>}\n        </div>\n      </Section>\n    </Container>\n  );\n}\n```\n\n2. Create the CSS module for styling the prologue page:\n```css\n/* src/app/session/[id]/prologue/prologue.module.css */\n.prologue-section {\n  margin-bottom: 2rem;\n  padding: 1.5rem;\n  border-radius: var(--radius-md);\n  background-color: var(--color-background-secondary);\n}\n\n.switch-container {\n  display: flex;\n  align-items: center;\n  gap: 1rem;\n  margin-top: 1rem;\n}\n\n.one-line-input {\n  width: 100%;\n  padding: 0.75rem;\n  border: 1px solid var(--color-border);\n  border-radius: var(--radius-sm);\n  font-size: var(--font-size-base);\n}\n\n.input-group {\n  display: flex;\n  gap: 0.5rem;\n}\n\n.success-message {\n  color: var(--color-success);\n  margin-top: 0.5rem;\n}\n\n.loading-indicator, .error-message {\n  text-align: center;\n  padding: 2rem;\n}\n\n.error-message {\n  color: var(--color-error);\n}\n```\n\n3. Implement the CopyToClipboard component if not already available:\n```tsx\n// src/components/ui/CopyToClipboard.tsx\n'use client';\n\nimport { useState } from 'react';\nimport Button from './Button';\n\ninterface CopyToClipboardProps {\n  text: string;\n}\n\nexport function CopyToClipboard({ text }: CopyToClipboardProps) {\n  const [copied, setCopied] = useState(false);\n\n  const handleCopy = async () => {\n    try {\n      await navigator.clipboard.writeText(text);\n      setCopied(true);\n      setTimeout(() => setCopied(false), 2000);\n    } catch (err) {\n      console.error('Failed to copy text: ', err);\n    }\n  };\n\n  return (\n    <Button \n      onClick={handleCopy} \n      variant=\"secondary\" \n      size=\"sm\"\n      className=\"copy-button\"\n    >\n      {copied ? 'Copied!' : 'Copy to Clipboard'}\n    </Button>\n  );\n}\n```\n\n4. Ensure the API endpoint for saving the one-line summary is properly handled:\n```tsx\n// This would be implemented in a separate task, but the endpoint would be:\n// src/app/api/session/[id]/prologue/route.ts\nimport { NextResponse } from 'next/server';\nimport { db } from '@/lib/db';\n\nexport async function POST(\n  request: Request,\n  { params }: { params: { id: string } }\n) {\n  try {\n    const { one_line } = await request.json();\n    const sessionId = params.id;\n\n    // Save the one-line summary to the database\n    await db.prologueData.upsert({\n      where: { sessionId },\n      update: { one_line },\n      create: { sessionId, one_line },\n    });\n\n    return NextResponse.json({ success: true });\n  } catch (error) {\n    console.error('Error saving prologue data:', error);\n    return NextResponse.json(\n      { error: 'Failed to save prologue data' },\n      { status: 500 }\n    );\n  }\n}\n```\n\n5. Add accessibility attributes to ensure the UI is accessible:\n   - Ensure proper heading hierarchy\n   - Add aria-labels to interactive elements\n   - Implement keyboard navigation for the form\n   - Ensure color contrast meets WCAG standards",
        "testStrategy": "1. Unit Testing:\n   - Test the ProloguePage component rendering:\n   ```tsx\n   // src/app/session/[id]/prologue/page.test.tsx\n   import { render, screen, waitFor, fireEvent } from '@testing-library/react';\n   import { useParams } from 'next/navigation';\n   import ProloguePage from './page';\n   \n   // Mock the next/navigation hooks\n   jest.mock('next/navigation', () => ({\n     useParams: jest.fn(),\n   }));\n   \n   // Mock fetch API\n   global.fetch = jest.fn();\n   \n   describe('ProloguePage', () => {\n     beforeEach(() => {\n       jest.clearAllMocks();\n       (useParams as jest.Mock).mockReturnValue({ id: 'test-session-id' });\n     });\n     \n     it('should display loading state initially', () => {\n       (global.fetch as jest.Mock).mockImplementationOnce(() => \n         new Promise(resolve => setTimeout(resolve, 100))\n       );\n       \n       render(<ProloguePage />);\n       expect(screen.getByText('Loading prologue data...')).toBeInTheDocument();\n     });\n     \n     it('should fetch and display prologue data', async () => {\n       const mockData = {\n         why_switch_explanation: 'Test explanation',\n         alternatives: ['Alt 1', 'Alt 2'],\n         narrative: 'Test narrative',\n         reflection_questions: ['Q1', 'Q2', 'Q3']\n       };\n       \n       (global.fetch as jest.Mock).mockResolvedValueOnce({\n         ok: true,\n         json: async () => mockData,\n       });\n       \n       render(<ProloguePage />);\n       \n       await waitFor(() => {\n         expect(screen.getByText('Test explanation')).toBeInTheDocument();\n         expect(screen.getByText('Alt 1')).toBeInTheDocument();\n         expect(screen.getByText('Test narrative')).toBeInTheDocument();\n         expect(screen.getByText('Q1')).toBeInTheDocument();\n       });\n     });\n     \n     it('should handle form submission', async () => {\n       const mockData = {\n         why_switch_explanation: 'Test explanation',\n         alternatives: ['Alt 1', 'Alt 2'],\n         narrative: 'Test narrative',\n         reflection_questions: ['Q1', 'Q2', 'Q3']\n       };\n       \n       (global.fetch as jest.Mock).mockResolvedValueOnce({\n         ok: true,\n         json: async () => mockData,\n       }).mockResolvedValueOnce({\n         ok: true,\n         json: async () => ({ success: true }),\n       });\n       \n       render(<ProloguePage />);\n       \n       await waitFor(() => {\n         expect(screen.getByPlaceholderText('Enter your one-line summary...')).toBeInTheDocument();\n       });\n       \n       const input = screen.getByPlaceholderText('Enter your one-line summary...');\n       fireEvent.change(input, { target: { value: 'My one-line summary' } });\n       \n       const submitButton = screen.getByText('Enter');\n       fireEvent.click(submitButton);\n       \n       await waitFor(() => {\n         expect(global.fetch).toHaveBeenCalledWith(\n           '/api/session/test-session-id/prologue',\n           expect.objectContaining({\n             method: 'POST',\n             body: JSON.stringify({ one_line: 'My one-line summary' }),\n           })\n         );\n         expect(screen.getByText('Successfully saved!')).toBeInTheDocument();\n       });\n     });\n     \n     it('should handle fetch errors', async () => {\n       (global.fetch as jest.Mock).mockRejectedValueOnce(new Error('Network error'));\n       \n       render(<ProloguePage />);\n       \n       await waitFor(() => {\n         expect(screen.getByText('Error: Network error')).toBeInTheDocument();\n       });\n     });\n   });\n   ```\n\n2. Integration Testing:\n   - Test the integration between the prologue page and the API endpoints:\n   ```tsx\n   // src/app/session/[id]/prologue/integration.test.tsx\n   import { render, screen, waitFor, fireEvent } from '@testing-library/react';\n   import { rest } from 'msw';\n   import { setupServer } from 'msw/node';\n   import ProloguePage from './page';\n   \n   // Mock the API endpoints\n   const server = setupServer(\n     rest.get('/api/session/:id/report', (req, res, ctx) => {\n       return res(\n         ctx.json({\n           why_switch_explanation: 'API explanation',\n           alternatives: ['API Alt 1', 'API Alt 2'],\n           narrative: 'API narrative',\n           reflection_questions: ['API Q1', 'API Q2', 'API Q3']\n         })\n       );\n     }),\n     rest.post('/api/session/:id/prologue', (req, res, ctx) => {\n       return res(ctx.json({ success: true }));\n     })\n   );\n   \n   beforeAll(() => server.listen());\n   afterEach(() => server.resetHandlers());\n   afterAll(() => server.close());\n   \n   // Integration tests...\n   ```\n\n3. End-to-End Testing:\n   - Use Cypress to test the complete user flow:\n   ```js\n   // cypress/e2e/prologue.cy.js\n   describe('Prologue Page', () => {\n     beforeEach(() => {\n       // Mock the API responses or use test data\n       cy.intercept('GET', '/api/session/*/report?type=prologue', {\n         fixture: 'prologue-data.json'\n       });\n       cy.intercept('POST', '/api/session/*/prologue', {\n         statusCode: 200,\n         body: { success: true }\n       });\n       \n       // Visit the prologue page\n       cy.visit('/session/test-id/prologue');\n     });\n     \n     it('should display all prologue sections', () => {\n       cy.contains('h2', 'Why ON/OFF Switch').should('be.visible');\n       cy.contains('h2', 'Alternatives').should('be.visible');\n       cy.contains('h2', 'Narrative').should('be.visible');\n       cy.contains('h2', 'Reflection Questions').should('be.visible');\n       cy.contains('h2', 'Your One-Line Summary').should('be.visible');\n     });\n     \n     it('should allow submitting a one-line summary', () => {\n       const summary = 'This is my test summary';\n       cy.get('.one-line-input').type(summary);\n       cy.contains('button', 'Enter').click();\n       cy.contains('Successfully saved!').should('be.visible');\n     });\n     \n     it('should copy narrative to clipboard', () => {\n       cy.contains('button', 'Copy to Clipboard').click();\n       cy.contains('Copied!').should('be.visible');\n       // Note: Actually testing clipboard content requires additional setup\n     });\n   });\n   ```\n\n4. Accessibility Testing:\n   - Test keyboard navigation through the page\n   - Verify screen reader compatibility\n   - Check color contrast for all UI elements\n   - Use axe or similar tools to check for accessibility issues:\n   ```js\n   // cypress/e2e/prologue-a11y.cy.js\n   describe('Prologue Page Accessibility', () => {\n     beforeEach(() => {\n       cy.visit('/session/test-id/prologue');\n       cy.injectAxe();\n     });\n     \n     it('should have no accessibility violations', () => {\n       cy.checkA11y();\n     });\n     \n     it('should be navigable with keyboard', () => {\n       cy.get('body').focus();\n       cy.tab().should('have.focus');\n       // Continue tabbing through interactive elements\n     });\n   });\n   ```",
        "status": "pending",
        "dependencies": [
          5,
          14
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Implement Prologue Page Navigation Flow and Analytics",
        "description": "Update the application routing to navigate to the prologue page after first-time report generation, implement analytics events tracking, and persist one-line input to the database with updated gate logic.",
        "details": "1. Update the navigation flow after first-time report generation:\n```typescript\n// In src/app/session/[id]/report/page.tsx or relevant component\nimport { useRouter } from 'next/navigation';\n\n// After successful report generation\nuseEffect(() => {\n  if (isFirstTimeGeneration && reportGenerationComplete) {\n    router.push(`/session/${sessionId}/prologue`);\n  }\n}, [isFirstTimeGeneration, reportGenerationComplete, sessionId, router]);\n```\n\n2. Implement analytics event tracking in the prologue page:\n```typescript\n// In src/app/session/[id]/prologue/page.tsx\nimport { trackEvent } from '@/utils/analytics';\n\n// Track page view\nuseEffect(() => {\n  trackEvent('prologue_view', { sessionId });\n}, [sessionId]);\n\n// Track why switch toggle\nconst handleWhySwitchToggle = (isEnabled: boolean) => {\n  setWhySwitchEnabled(isEnabled);\n  trackEvent('why_switch_toggled', { sessionId, isEnabled });\n};\n\n// Track one-line submission\nconst handleOneLineSubmit = (text: string) => {\n  trackEvent('one_line_submit', { sessionId });\n  saveOneLineInput(text);\n};\n\n// Track copy why action\nconst handleCopyWhy = () => {\n  trackEvent('copy_why', { sessionId });\n};\n```\n\n3. Create API endpoint to persist one-line input to the database:\n```typescript\n// In src/app/api/session/[id]/one-line/route.ts\nimport { NextResponse } from 'next/server';\nimport { db } from '@/lib/db';\n\nexport async function POST(\n  request: Request,\n  { params }: { params: { id: string } }\n) {\n  const sessionId = params.id;\n  const { text } = await request.json();\n\n  try {\n    // Update the session with the one-line input\n    await db.session.update({\n      where: { id: sessionId },\n      data: {\n        oneLineInput: text,\n        prologueCompleted: true\n      }\n    });\n\n    return NextResponse.json({ success: true });\n  } catch (error) {\n    console.error('Error saving one-line input:', error);\n    return NextResponse.json(\n      { error: 'Failed to save one-line input' },\n      { status: 500 }\n    );\n  }\n}\n```\n\n4. Implement the function to save one-line input:\n```typescript\n// In src/app/session/[id]/prologue/page.tsx\nconst saveOneLineInput = async (text: string) => {\n  setIsSaving(true);\n  try {\n    const response = await fetch(`/api/session/${id}/one-line`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ text })\n    });\n    \n    if (!response.ok) {\n      throw new Error('Failed to save one-line input');\n    }\n    \n    setIsSaving(false);\n    setSaveSuccess(true);\n  } catch (error) {\n    console.error('Error saving one-line input:', error);\n    setIsSaving(false);\n    setSaveError(true);\n  }\n};\n```\n\n5. Update gate logic to include prologue viewed state:\n```typescript\n// In src/utils/gateLogic.ts or relevant file\nexport const canAccessWhyPage = async (sessionId: string) => {\n  const session = await db.session.findUnique({\n    where: { id: sessionId },\n    select: { \n      hasGeneratedReport: true,\n      prologueCompleted: true \n    }\n  });\n  \n  return session?.hasGeneratedReport && session?.prologueCompleted;\n};\n\n// Update middleware or route handlers to use this gate logic\n// In src/middleware.ts or relevant route protection file\nimport { canAccessWhyPage } from '@/utils/gateLogic';\n\n// Example middleware implementation\nexport async function middleware(request: NextRequest) {\n  const pathname = request.nextUrl.pathname;\n  \n  // Check if trying to access why page\n  if (pathname.match(/^\\/session\\/[^\\/]+\\/why$/)) {\n    const sessionId = pathname.split('/')[2];\n    const canAccess = await canAccessWhyPage(sessionId);\n    \n    if (!canAccess) {\n      // Redirect to appropriate page based on state\n      const session = await db.session.findUnique({\n        where: { id: sessionId },\n        select: { hasGeneratedReport: true }\n      });\n      \n      if (session?.hasGeneratedReport) {\n        // Has report but hasn't completed prologue\n        return NextResponse.redirect(new URL(`/session/${sessionId}/prologue`, request.url));\n      } else {\n        // Hasn't generated report yet\n        return NextResponse.redirect(new URL(`/session/${sessionId}/report`, request.url));\n      }\n    }\n  }\n  \n  return NextResponse.next();\n}\n```\n\n6. Add database schema updates for the new fields:\n```typescript\n// In prisma/schema.prisma (or relevant database schema file)\nmodel Session {\n  // Existing fields\n  id                String    @id @default(uuid())\n  // ...\n  \n  // New fields\n  oneLineInput      String?\n  prologueCompleted Boolean   @default(false)\n  // ...\n}\n```",
        "testStrategy": "1. Unit Testing:\n   - Test the navigation flow after report generation:\n   ```typescript\n   // In src/app/session/[id]/report/page.test.tsx\n   import { render, screen, waitFor } from '@testing-library/react';\n   import { useRouter } from 'next/navigation';\n   import ReportPage from './page';\n   \n   jest.mock('next/navigation', () => ({\n     useRouter: jest.fn(),\n     useParams: () => ({ id: 'test-session-id' })\n   }));\n   \n   describe('ReportPage navigation', () => {\n     it('should navigate to prologue page after first-time report generation', async () => {\n       const mockPush = jest.fn();\n       (useRouter as jest.Mock).mockReturnValue({ push: mockPush });\n       \n       // Mock the report generation state\n       jest.mock('@/hooks/useReportStatus', () => ({\n         useReportStatus: () => ({\n           isFirstTimeGeneration: true,\n           reportGenerationComplete: true\n         })\n       }));\n       \n       render(<ReportPage />);\n       \n       await waitFor(() => {\n         expect(mockPush).toHaveBeenCalledWith('/session/test-session-id/prologue');\n       });\n     });\n   });\n   ```\n\n2. Test analytics event tracking:\n   ```typescript\n   // In src/app/session/[id]/prologue/page.test.tsx\n   import { render, screen, fireEvent } from '@testing-library/react';\n   import { trackEvent } from '@/utils/analytics';\n   import ProloguePage from './page';\n   \n   jest.mock('@/utils/analytics', () => ({\n     trackEvent: jest.fn()\n   }));\n   \n   describe('ProloguePage analytics', () => {\n     beforeEach(() => {\n       jest.clearAllMocks();\n     });\n     \n     it('should track page view on load', () => {\n       render(<ProloguePage />);\n       expect(trackEvent).toHaveBeenCalledWith('prologue_view', expect.any(Object));\n     });\n     \n     it('should track why switch toggle', () => {\n       render(<ProloguePage />);\n       const switchElement = screen.getByRole('switch');\n       fireEvent.click(switchElement);\n       expect(trackEvent).toHaveBeenCalledWith('why_switch_toggled', expect.objectContaining({\n         isEnabled: true\n       }));\n     });\n     \n     it('should track one-line submission', () => {\n       render(<ProloguePage />);\n       const inputElement = screen.getByPlaceholderText(/one line/i);\n       const submitButton = screen.getByRole('button', { name: /submit/i });\n       \n       fireEvent.change(inputElement, { target: { value: 'Test input' } });\n       fireEvent.click(submitButton);\n       \n       expect(trackEvent).toHaveBeenCalledWith('one_line_submit', expect.any(Object));\n     });\n     \n     it('should track copy why action', () => {\n       render(<ProloguePage />);\n       const copyButton = screen.getByRole('button', { name: /copy/i });\n       \n       fireEvent.click(copyButton);\n       \n       expect(trackEvent).toHaveBeenCalledWith('copy_why', expect.any(Object));\n     });\n   });\n   ```\n\n3. API Endpoint Testing:\n   ```typescript\n   // In src/app/api/session/[id]/one-line/route.test.ts\n   import { POST } from './route';\n   import { db } from '@/lib/db';\n   \n   jest.mock('@/lib/db', () => ({\n     db: {\n       session: {\n         update: jest.fn()\n       }\n     }\n   }));\n   \n   describe('POST /api/session/[id]/one-line', () => {\n     beforeEach(() => {\n       jest.clearAllMocks();\n     });\n     \n     it('should update the session with one-line input', async () => {\n       const mockRequest = new Request('http://localhost/api/session/test-id/one-line', {\n         method: 'POST',\n         headers: {\n           'Content-Type': 'application/json'\n         },\n         body: JSON.stringify({ text: 'Test one-line input' })\n       });\n       \n       (db.session.update as jest.Mock).mockResolvedValue({ id: 'test-id' });\n       \n       const response = await POST(mockRequest, { params: { id: 'test-id' } });\n       const data = await response.json();\n       \n       expect(db.session.update).toHaveBeenCalledWith({\n         where: { id: 'test-id' },\n         data: {\n           oneLineInput: 'Test one-line input',\n           prologueCompleted: true\n         }\n       });\n       \n       expect(data).toEqual({ success: true });\n     });\n     \n     it('should handle errors properly', async () => {\n       const mockRequest = new Request('http://localhost/api/session/test-id/one-line', {\n         method: 'POST',\n         headers: {\n           'Content-Type': 'application/json'\n         },\n         body: JSON.stringify({ text: 'Test one-line input' })\n       });\n       \n       (db.session.update as jest.Mock).mockRejectedValue(new Error('Database error'));\n       \n       const response = await POST(mockRequest, { params: { id: 'test-id' } });\n       const data = await response.json();\n       \n       expect(response.status).toBe(500);\n       expect(data).toEqual({ error: 'Failed to save one-line input' });\n     });\n   });\n   ```\n\n4. Gate Logic Testing:\n   ```typescript\n   // In src/utils/gateLogic.test.ts\n   import { canAccessWhyPage } from './gateLogic';\n   import { db } from '@/lib/db';\n   \n   jest.mock('@/lib/db', () => ({\n     db: {\n       session: {\n         findUnique: jest.fn()\n       }\n     }\n   }));\n   \n   describe('Gate Logic', () => {\n     beforeEach(() => {\n       jest.clearAllMocks();\n     });\n     \n     it('should allow access when report is generated and prologue is completed', async () => {\n       (db.session.findUnique as jest.Mock).mockResolvedValue({\n         hasGeneratedReport: true,\n         prologueCompleted: true\n       });\n       \n       const result = await canAccessWhyPage('test-id');\n       expect(result).toBe(true);\n     });\n     \n     it('should deny access when report is generated but prologue is not completed', async () => {\n       (db.session.findUnique as jest.Mock).mockResolvedValue({\n         hasGeneratedReport: true,\n         prologueCompleted: false\n       });\n       \n       const result = await canAccessWhyPage('test-id');\n       expect(result).toBe(false);\n     });\n     \n     it('should deny access when neither report is generated nor prologue is completed', async () => {\n       (db.session.findUnique as jest.Mock).mockResolvedValue({\n         hasGeneratedReport: false,\n         prologueCompleted: false\n       });\n       \n       const result = await canAccessWhyPage('test-id');\n       expect(result).toBe(false);\n     });\n   });\n   ```\n\n5. Integration Testing:\n   - Test the complete flow from report generation to prologue to why page:\n   ```typescript\n   // In cypress/e2e/report-prologue-flow.cy.ts\n   describe('Report to Prologue to Why Page Flow', () => {\n     beforeEach(() => {\n       // Set up test session and login\n       cy.login();\n       cy.createTestSession();\n     });\n     \n     it('should navigate through the complete flow', () => {\n       // Start at report generation\n       cy.visit('/session/test-session-id/report');\n       \n       // Wait for report generation to complete\n       cy.get('[data-testid=\"report-generation-complete\"]', { timeout: 10000 }).should('be.visible');\n       \n       // Should automatically navigate to prologue\n       cy.url().should('include', '/session/test-session-id/prologue');\n       \n       // Interact with prologue page\n       cy.get('[data-testid=\"one-line-input\"]').type('This is my one line summary');\n       cy.get('[data-testid=\"submit-button\"]').click();\n       \n       // Verify submission success\n       cy.get('[data-testid=\"success-message\"]').should('be.visible');\n       \n       // Navigate to why page\n       cy.get('[data-testid=\"continue-to-why\"]').click();\n       \n       // Verify we're on the why page\n       cy.url().should('include', '/session/test-session-id/why');\n     });\n     \n     it('should block access to why page if prologue not completed', () => {\n       // Set up session with report but no prologue\n       cy.setupSessionWithReport();\n       \n       // Try to access why page directly\n       cy.visit('/session/test-session-id/why');\n       \n       // Should be redirected to prologue\n       cy.url().should('include', '/session/test-session-id/prologue');\n     });\n   });\n   ```",
        "status": "pending",
        "dependencies": [
          14,
          15,
          11,
          12,
          13
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-28T09:03:47.432Z",
      "updated": "2025-09-01T07:51:03.770Z",
      "description": "Design refresh applying design-ref across all pages/components"
    }
  },
  "feature-report-v2": {
    "tasks": [
      {
        "id": 1,
        "title": "Report v2 Restructuring Initiative - Schema and Type Definitions",
        "description": "Define comprehensive type definitions for all report sections (Ch0-Ch9) in src/types/report.ts, ensuring proper versioning and type safety across the entire report structure.",
        "details": "This task involves creating a complete type system for the report v2 restructuring initiative:\n\n1. Update src/types/report.ts to include type definitions for all report sections (Ch0-Ch9)\n2. Implement proper versioning for each section type to support backward compatibility\n3. Define interfaces for all data structures used in the report\n4. Create type guards and utility types to ensure type safety during report generation\n5. Document each type with JSDoc comments explaining its purpose and usage\n6. Ensure types align with the JSON schema expected by the API\n7. Create specific types for different report sections:\n   - Base report type that all sections extend\n   - Section-specific types (Ch0-Ch9) with their unique properties\n   - Types for my_why JSON-only section\n   - Types for markdown template sections\n8. Add validation type predicates to help with runtime type checking\n9. Ensure exported types are properly named and organized for easy imports\n10. Consider edge cases like optional fields, nullable values, and array types\n\nExample structure:\n```typescript\n// Base report type\nexport interface ReportBase {\n  version: string;\n  lastUpdated: string;\n  // Common fields\n}\n\n// Chapter-specific types\nexport interface Ch0Section extends ReportBase {\n  // Ch0-specific fields\n}\n\n// ... other chapter types\n\n// Type guards\nexport function isCh0Section(section: any): section is Ch0Section {\n  // Implementation\n}\n\n// Utility types\nexport type AllReportSections = Ch0Section | Ch1Section | /* ... */;\n```",
        "testStrategy": "1. Create unit tests for all type definitions:\n   - Test type guards with valid and invalid inputs\n   - Verify type compatibility with mock data\n   - Test edge cases like null/undefined values\n\n2. Integration testing:\n   - Import types in relevant components and verify no type errors\n   - Test serialization/deserialization of typed objects to/from JSON\n   - Verify API responses conform to defined types\n\n3. Manual verification:\n   - Review type definitions with team members\n   - Ensure all required fields from the specification are included\n   - Check that types are properly exported and accessible\n\n4. Documentation validation:\n   - Verify JSDoc comments are complete and accurate\n   - Ensure type examples are provided where helpful\n   - Check that naming conventions are consistent\n\n5. Compatibility testing:\n   - Test with existing code that will use these types\n   - Verify backward compatibility with previous report versions\n   - Check that version handling works as expected\n\n6. Static analysis:\n   - Run TypeScript compiler in strict mode to catch any issues\n   - Use tools like tsc --noEmit to verify type correctness",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Base Report Type and Common Interfaces",
            "description": "Create the foundational ReportBase interface and common utility types that all report sections will extend. Include version control fields and shared properties.",
            "dependencies": [],
            "details": "In src/types/report.ts, define the ReportBase interface with version, lastUpdated, and other common fields. Create utility types for handling versioning (e.g., VersionedType<T>). Include JSDoc comments for each type. Define enums for report section identifiers and status values that will be used across all sections.",
            "status": "pending",
            "testStrategy": "Create unit tests to verify the structure of the base types. Test with sample objects to ensure they conform to the expected interface."
          },
          {
            "id": 2,
            "title": "Implement Ch0-Ch3 Section Type Definitions",
            "description": "Define specific type interfaces for the first four report chapters (Ch0-Ch3), ensuring they extend the base report type and include their unique properties.",
            "dependencies": [],
            "details": "Create interfaces for Ch0Section, Ch1Section, Ch2Section, and Ch3Section that extend ReportBase. Include all section-specific fields with proper types and JSDoc documentation. Define nested types for complex structures within these sections. Implement version-specific interfaces if backward compatibility is needed.",
            "status": "pending",
            "testStrategy": "Test each section type with mock data representing real-world usage. Verify type compatibility and inheritance from ReportBase."
          },
          {
            "id": 3,
            "title": "Implement Ch4-Ch9 Section Type Definitions",
            "description": "Define specific type interfaces for the remaining report chapters (Ch4-Ch9), following the same pattern established for the earlier chapters.",
            "dependencies": [],
            "details": "Create interfaces for Ch4Section through Ch9Section that extend ReportBase. Include all section-specific fields with proper types and JSDoc documentation. Define nested types for complex structures within these sections. Ensure consistency with the type patterns established in the previous subtask.",
            "status": "pending",
            "testStrategy": "Test each section type with mock data representing real-world usage. Verify type compatibility and inheritance from ReportBase."
          },
          {
            "id": 4,
            "title": "Create my_why JSON-only Section Types",
            "description": "Implement specialized types for the my_why section which has a JSON-only structure different from other report sections.",
            "dependencies": [],
            "details": "Define MyWhySection interface extending ReportBase with specific fields for the my_why content. Create nested types for the unique JSON structure of this section. Include types for any special processing or formatting requirements specific to my_why content.",
            "status": "pending",
            "testStrategy": "Test the my_why types with sample JSON data. Verify that the types accurately represent the expected structure and handle edge cases appropriately."
          },
          {
            "id": 5,
            "title": "Implement Type Guards and Type Predicates",
            "description": "Create type guard functions for runtime type checking of report sections and implement validation predicates for each section type.",
            "dependencies": [],
            "details": "Implement functions like isCh0Section, isCh1Section, etc., that validate if an object conforms to the expected type structure. Create a comprehensive isReportSection function that can identify any section type. Add specific validation predicates for checking required fields and data integrity within each section type.",
            "status": "pending",
            "testStrategy": "Create unit tests with valid and invalid inputs for each type guard. Verify that the guards correctly identify matching and non-matching objects."
          },
          {
            "id": 6,
            "title": "Define Union Types and Type Utilities",
            "description": "Create union types representing all possible report sections and implement utility types for common operations on report data.",
            "dependencies": [],
            "details": "Define AllReportSections as a union of all section types. Create utility types like ReportSectionMap for mapping section IDs to their respective types. Implement helper types for common transformations (e.g., PartialReport, ReportSectionKeys). Add type utilities for handling optional fields and nullable values consistently across the report structure.",
            "status": "pending",
            "testStrategy": "Test the union and utility types with various combinations of report sections. Verify that type inference works correctly when using these types in sample code."
          },
          {
            "id": 7,
            "title": "Add Markdown Template Section Types",
            "description": "Implement specialized types for sections that use markdown templates, including any parsing or rendering metadata needed.",
            "dependencies": [],
            "details": "Create MarkdownTemplateSection interface that extends ReportBase with fields for template content, variables, and rendering options. Define types for template variable substitution and markdown processing options. Include types for template metadata like author, creation date, and template version.",
            "status": "pending",
            "testStrategy": "Test the markdown template types with sample template data. Verify that the types support all required template features and variable substitution patterns."
          },
          {
            "id": 8,
            "title": "Ensure API Schema Compatibility and Export Type Definitions",
            "description": "Finalize the type system to ensure compatibility with the API's JSON schema and organize exports for easy consumption by other modules.",
            "dependencies": [],
            "details": "Review all types to ensure alignment with the API's expected JSON schema. Add any missing fields or constraints required by the API. Organize type exports with named exports for individual types and namespace exports for related type groups. Create index files if needed for simplified imports. Add comprehensive JSDoc comments to all exported types explaining their purpose, usage, and any special considerations.",
            "status": "pending",
            "testStrategy": "Perform integration testing by importing the types in components that use the API. Verify that sample API responses can be properly typed with the defined interfaces. Test the export structure by importing types in various ways to ensure they're accessible as expected."
          }
        ]
      },
      {
        "id": 2,
        "title": "API Session Report Prompt Reconstruction and Type Integration",
        "description": "Restore and restructure the buildPrompt functionality for /api/session/[id]/report endpoint with type-based prompt branching, integrating my_why JSON schema options and maintaining markdown templates for other types.",
        "details": "This task involves reconstructing the buildPrompt functionality for the session report API with the following implementation steps:\n\n1. Restore the broken buildPrompt functionality in the /api/session/[id]/report endpoint\n2. Implement type-based prompt branching logic to handle different prompt types:\n   - Identify and remove broken text segments from the current implementation\n   - Integrate the my_why JSON schema with the following options:\n     - ON/OFF states\n     - narrative format\n     - questions format\n     - one_line format\n     - cta (call to action) format\n     - post_prompt format\n   - Maintain existing markdown templates for all other prompt types\n3. Implement and verify the following control operations:\n   - check: Verify prompt structure without modifying\n   - force: Override existing prompt with new structure\n   - cascade: Apply changes to dependent prompts\n   - reset: Restore default prompt structure\n4. Update the API handler to properly process the reconstructed prompt based on type\n5. Ensure type safety by leveraging the report type definitions from Task #1\n6. Add error handling for malformed prompts or invalid type specifications\n7. Document the new prompt structure and branching logic for future reference\n\nCode structure should follow:\n```typescript\n// Example prompt branching logic\nfunction buildPrompt(session: Session, type: PromptType, options: PromptOptions): string {\n  // Remove broken text segments\n  const cleanedSession = removeInvalidTextSegments(session);\n  \n  switch(type) {\n    case 'my_why':\n      return buildMyWhyPrompt(cleanedSession, options);\n    // Other cases for different prompt types\n    default:\n      return existingMarkdownTemplates[type] || '';\n  }\n}\n\n// my_why JSON schema integration\nfunction buildMyWhyPrompt(session: Session, options: MyWhyOptions): string {\n  const { state, format } = options;\n  \n  if (state === 'OFF') return '';\n  \n  switch(format) {\n    case 'narrative': \n      return `${narrativeTemplate}`;\n    case 'questions':\n      return `${questionsTemplate}`;\n    // Other format cases\n  }\n}\n```",
        "testStrategy": "1. Unit Testing:\n   - Create unit tests for each prompt type to verify correct structure\n   - Test all my_why JSON schema options (ON/OFF/narrative/questions/one_line/cta/post_prompt)\n   - Verify proper handling of broken text segments\n   - Test each control operation (check/force/cascade/reset) with various inputs\n\n2. Integration Testing:\n   - Test the API endpoint with various session IDs and prompt types\n   - Verify correct prompt generation for each type\n   - Test error handling with malformed requests\n   - Validate JSON schema compliance for my_why prompt types\n\n3. End-to-End Testing:\n   - Create test sessions and generate reports through the API\n   - Verify the generated prompts match expected output\n   - Test the full workflow from session creation to report generation\n\n4. Regression Testing:\n   - Ensure existing functionality for other prompt types is preserved\n   - Verify backward compatibility with existing reports\n\n5. Manual Testing:\n   - Review generated prompts for correctness and formatting\n   - Verify proper handling of edge cases like empty sessions or missing data",
        "status": "in-progress",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Ch0 My Why Integration: Data Structure, Prompt Formatting, and UI Binding",
        "description": "Finalize the Ch0 My Why and Prologue integration by establishing data structures, formatting JSON prompts, enhancing API validation, and implementing UI bindings for interactive elements.",
        "details": "This task involves finalizing the Ch0 My Why and Prologue integration with the following implementation steps:\n\n1. Data Structure Finalization:\n   - Define and document all data states (ON/OFF toggles)\n   - Structure narrative content format requirements\n   - Formalize question formats and validation rules\n   - Define one-line summary data structure\n   - Document call-to-action (CTA) format requirements\n   - Establish post-prompt data structure\n\n2. JSON Prompt Formatting:\n   - Create standardized JSON templates for My Why prompts\n   - Implement proper nesting and hierarchy for all prompt components\n   - Ensure all prompts follow the established schema from Task #1\n   - Document the JSON structure with examples for each prompt type\n   - Implement serialization/deserialization utilities for the prompt data\n\n3. API Validation Enhancement:\n   - Extend the validateAndFill function to handle all Ch0 data types\n   - Implement validation rules for each data component\n   - Add error handling for malformed or incomplete data\n   - Create data normalization functions to ensure consistency\n   - Document API validation requirements and error codes\n\n4. UI Binding Implementation:\n   - Connect toggle switches to the ON/OFF state data\n   - Bind narrative sections to the corresponding data fields\n   - Implement question rendering and response handling\n   - Create one-line summary input and display components\n   - Ensure all UI elements properly reflect the underlying data state\n   - Implement real-time validation feedback for user inputs\n\n5. Integration with Existing Systems:\n   - Ensure compatibility with the prompt building system from Task #2\n   - Verify type safety using the schema definitions from Task #1\n   - Document integration points and dependencies",
        "testStrategy": "1. Unit Testing:\n   - Test each data structure component with valid and invalid inputs\n   - Verify JSON prompt formatting produces valid output for all scenarios\n   - Test validateAndFill function with various input combinations\n   - Validate UI binding functions with mock data\n\n2. Integration Testing:\n   - Test the complete flow from UI interaction to data storage\n   - Verify API responses with different combinations of input data\n   - Test error handling and validation feedback in the UI\n   - Ensure proper state management across UI components\n\n3. UI Component Testing:\n   - Test toggle switches for proper ON/OFF state management\n   - Verify narrative sections render and update correctly\n   - Test question components for proper rendering and response handling\n   - Validate one-line summary input and display functionality\n\n4. End-to-End Testing:\n   - Create test scenarios covering the complete user journey\n   - Verify data persistence across page refreshes\n   - Test integration with the report generation system\n   - Validate proper display of all UI elements based on data state\n\n5. Regression Testing:\n   - Ensure changes don't break existing functionality\n   - Verify compatibility with other report sections\n   - Test backward compatibility with existing data",
        "status": "in-progress",
        "dependencies": [
          1,
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Ch1 Value Map: Data Field Definition, Template Markdown Prompt, API Storage/Cascade, and UI Section Binding",
        "description": "Define and implement the Ch1 Value Map component by finalizing data fields, creating markdown prompt templates, establishing API storage with cascade functionality, and binding UI sections to the data structure.",
        "details": "This task involves implementing the Ch1 Value Map component with the following steps:\n\n1. Data Field Definition:\n   - Define all required data fields for the Value Map component\n   - Document field types, validation rules, and constraints\n   - Establish relationships between fields\n   - Create schema validation for input data\n   - Define default values and initialization logic\n\n2. Template Markdown Prompt:\n   - Create standardized markdown templates for the Value Map prompts\n   - Implement variable substitution in templates\n   - Design prompt structure with clear sections for user guidance\n   - Ensure proper formatting and readability\n   - Include conditional sections based on user progress\n\n3. API Storage and Cascade Implementation:\n   - Extend the session report API to handle Value Map data\n   - Implement storage logic for saving Value Map responses\n   - Create cascade functionality to update dependent fields\n   - Add validation middleware for incoming data\n   - Implement versioning for backward compatibility\n   - Create endpoints for retrieving and updating Value Map data\n\n4. UI Section Binding:\n   - Create UI components for Value Map sections\n   - Implement data binding between UI and API\n   - Add real-time validation and feedback\n   - Ensure responsive design for all screen sizes\n   - Implement state management for form interactions\n   - Add accessibility features for all interactive elements\n\n5. Integration with Existing Components:\n   - Connect Value Map with Ch0 My Why data where relevant\n   - Ensure proper navigation between chapters\n   - Maintain consistent user experience across sections\n   - Implement progress tracking between chapters",
        "testStrategy": "1. Unit Testing:\n   - Test each data field with valid and invalid inputs\n   - Verify markdown template rendering with various data inputs\n   - Test API endpoints for storing and retrieving Value Map data\n   - Validate cascade functionality with different update scenarios\n   - Test UI components in isolation with mock data\n\n2. Integration Testing:\n   - Verify data flow between UI components and API\n   - Test navigation between Ch0 and Ch1 sections\n   - Ensure proper state management across the application\n   - Validate form submission and error handling\n   - Test cascade updates across dependent components\n\n3. End-to-End Testing:\n   - Create test scenarios covering the complete user journey\n   - Verify data persistence across page refreshes\n   - Test performance with large datasets\n   - Validate responsive design across different devices\n   - Ensure accessibility compliance\n\n4. User Acceptance Testing:\n   - Prepare test scripts for manual verification\n   - Document expected behavior for each interaction\n   - Verify content accuracy and prompt clarity\n   - Test edge cases and recovery scenarios\n   - Validate overall user experience",
        "status": "pending",
        "dependencies": [
          1,
          2,
          3
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Ch2 Style Pattern: Data Field Definition, Template Markdown Prompt, API Storage/Cascade, and UI Section Binding",
        "description": "Define and implement the Ch2 Style Pattern component by finalizing data fields, creating markdown prompt templates, establishing API storage with cascade functionality, and binding UI sections to the data structure.",
        "details": "This task involves implementing the Ch2 Style Pattern component with the following steps:\n\n1. Data Field Definition:\n   - Define all required data fields for the Style Pattern component\n   - Document field types, validation rules, and constraints\n   - Establish relationships between fields\n   - Create schema validation for input data\n   - Define default values and initialization logic\n   - Ensure compatibility with the overall report structure defined in Task #1\n\n2. Template Markdown Prompt:\n   - Create standardized markdown templates for the Style Pattern prompts\n   - Implement variable substitution for dynamic content\n   - Design templates for different user interaction states\n   - Ensure proper formatting and readability\n   - Implement conditional sections based on user inputs\n   - Document template structure and usage guidelines\n\n3. API Storage/Cascade:\n   - Implement API endpoints for storing Style Pattern data\n   - Develop cascade functionality to update dependent sections\n   - Ensure proper validation before storage\n   - Implement error handling and recovery mechanisms\n   - Create data transformation functions for API requests/responses\n   - Document API endpoints and expected payloads\n   - Implement versioning support for backward compatibility\n\n4. UI Section Binding:\n   - Create UI components for the Style Pattern section\n   - Bind UI elements to the data structure\n   - Implement real-time validation and feedback\n   - Ensure responsive design for different screen sizes\n   - Develop interactive elements for user engagement\n   - Implement state management for the UI components\n   - Create animations and transitions for improved UX\n   - Ensure accessibility compliance\n\n5. Integration with Previous Chapters:\n   - Establish data flow between Ch1 Value Map and Ch2 Style Pattern\n   - Ensure consistent user experience across chapters\n   - Implement navigation between related sections\n   - Create visual indicators for completed sections",
        "testStrategy": "1. Unit Testing:\n   - Test each data field with valid and invalid inputs\n   - Verify markdown template rendering with various data inputs\n   - Test API endpoints for storing and retrieving Style Pattern data\n   - Validate cascade functionality with different update scenarios\n   - Test UI components in isolation with mock data\n   - Verify state management with different user interactions\n\n2. Integration Testing:\n   - Test the integration between data fields, templates, and UI components\n   - Verify data flow between API and UI components\n   - Test navigation between Ch1 Value Map and Ch2 Style Pattern\n   - Validate cascade updates across dependent sections\n   - Test the complete user journey through the Style Pattern section\n\n3. Regression Testing:\n   - Ensure changes don't break existing functionality\n   - Verify compatibility with previous chapters\n   - Test backward compatibility with existing data\n\n4. User Acceptance Testing:\n   - Verify the Style Pattern section meets design requirements\n   - Test usability with different user personas\n   - Validate content clarity and guidance\n\n5. Performance Testing:\n   - Measure rendering time for complex templates\n   - Test API response times under load\n   - Verify UI responsiveness during data operations",
        "status": "pending",
        "dependencies": [
          1,
          2,
          3,
          4
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Ch3 Master-Manager Spectrum: Data Field Definition, Template Markdown Prompt, API Storage/Cascade, and UI Section Binding",
        "description": "Define and implement the Ch3 Master-Manager Spectrum component by finalizing data fields, creating markdown prompt templates, establishing API storage with cascade functionality, and binding UI sections to the data structure.",
        "details": "This task involves implementing the Ch3 Master-Manager Spectrum component with the following steps:\n\n1. Data Field Definition:\n   - Define all required data fields for the Master-Manager Spectrum component\n   - Document field types, validation rules, and constraints\n   - Establish relationships between fields\n   - Create schema validation for input data\n   - Define default values and initialization logic\n   - Ensure compatibility with the overall report structure defined in Task #1\n\n2. Template Markdown Prompt:\n   - Create standardized markdown templates for the Master-Manager Spectrum prompts\n   - Implement variable substitution for dynamic content\n   - Design templates for different sections of the spectrum analysis\n   - Include conditional rendering logic based on user inputs\n   - Ensure templates follow the established style guidelines\n   - Create helper functions for formatting complex data structures\n\n3. API Storage/Cascade:\n   - Implement API endpoints for storing Master-Manager Spectrum data\n   - Develop cascade functionality to propagate changes to dependent sections\n   - Create validation middleware for incoming data\n   - Implement versioning for data structure changes\n   - Design efficient data retrieval methods\n   - Establish error handling and recovery mechanisms\n   - Implement transaction support for multi-step operations\n\n4. UI Section Binding:\n   - Create UI components for the Master-Manager Spectrum section\n   - Bind UI elements to the data structure\n   - Implement real-time validation and feedback\n   - Design interactive elements for spectrum positioning\n   - Create visualization components for spectrum data\n   - Implement state management for complex interactions\n   - Ensure responsive design for different screen sizes\n   - Add accessibility features for all interactive elements\n\n5. Integration with Previous Chapters:\n   - Ensure proper data flow between Ch2 Style Pattern and Ch3 Master-Manager Spectrum\n   - Implement references to previous chapter data where appropriate\n   - Maintain consistent user experience across chapter transitions",
        "testStrategy": "1. Unit Testing:\n   - Test each data field with valid and invalid inputs\n   - Verify markdown template rendering with various data inputs\n   - Test API endpoints for storing and retrieving Master-Manager Spectrum data\n   - Validate cascade functionality with different update scenarios\n   - Test UI components in isolation with mock data\n   - Verify state management with complex interaction sequences\n\n2. Integration Testing:\n   - Test data flow between Ch2 Style Pattern and Ch3 Master-Manager Spectrum\n   - Verify UI rendering with real API responses\n   - Test end-to-end user flows through the Master-Manager Spectrum section\n   - Validate cross-component interactions\n   - Test error handling and recovery scenarios\n   - Verify performance under load conditions\n\n3. User Acceptance Testing:\n   - Create test scenarios for common user journeys\n   - Verify that the Master-Manager Spectrum accurately represents user inputs\n   - Test the intuitiveness of the spectrum positioning interface\n   - Validate that the generated content meets business requirements\n   - Ensure the UI is accessible and responsive across devices\n\n4. Regression Testing:\n   - Verify that changes don't affect functionality in Ch0-Ch2\n   - Test backward compatibility with existing report data\n   - Validate that the cascade functionality properly updates dependent sections",
        "status": "pending",
        "dependencies": [
          1,
          2,
          3,
          4,
          5
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Ch4 Fit & Triggers: Data Field Definition, Template Markdown Prompt, API Storage/Cascade, and UI Section Binding",
        "description": "Define and implement the Ch4 Fit & Triggers component by finalizing data fields, creating markdown prompt templates, establishing API storage with cascade functionality, and binding UI sections to the data structure.",
        "details": "This task involves implementing the Ch4 Fit & Triggers component with the following steps:\n\n1. Data Field Definition:\n   - Define all required data fields for the Fit & Triggers component\n   - Document field types, validation rules, and constraints\n   - Establish relationships between fields\n   - Create schema validation for input data\n   - Define default values and initialization logic\n   - Ensure compatibility with the overall report structure defined in Task #1\n\n2. Template Markdown Prompt:\n   - Create standardized markdown templates for the Fit & Triggers prompts\n   - Implement variable substitution for dynamic content\n   - Design templates for different user interaction scenarios\n   - Ensure proper formatting and readability\n   - Include conditional sections based on user inputs\n   - Document template usage and customization options\n\n3. API Storage/Cascade:\n   - Implement API endpoints for storing Fit & Triggers data\n   - Develop cascade functionality to update dependent components when data changes\n   - Ensure proper validation before storage\n   - Implement error handling and recovery mechanisms\n   - Create documentation for API usage\n   - Optimize for performance with potential caching strategies\n\n4. UI Section Binding:\n   - Bind UI components to the Fit & Triggers data structure\n   - Implement real-time updates when data changes\n   - Create interactive elements for user input\n   - Ensure responsive design for different screen sizes\n   - Implement validation feedback for user inputs\n   - Design intuitive navigation between related sections\n   - Ensure accessibility compliance\n\n5. Integration with Previous Chapters:\n   - Ensure proper data flow between Ch3 Master-Manager Spectrum and Ch4 Fit & Triggers\n   - Implement cross-referencing between related components\n   - Maintain consistency in UI/UX patterns established in previous chapters\n   - Document dependencies and integration points",
        "testStrategy": "1. Unit Testing:\n   - Test each data field with valid and invalid inputs\n   - Verify markdown template rendering with various data inputs\n   - Test API endpoints for storing and retrieving Fit & Triggers data\n   - Validate cascade functionality with different update scenarios\n   - Test UI components in isolation with mock data\n   - Verify error handling for all edge cases\n\n2. Integration Testing:\n   - Test data flow between Ch3 Master-Manager Spectrum and Ch4 Fit & Triggers\n   - Verify UI updates when API data changes\n   - Test end-to-end user workflows involving multiple components\n   - Validate cross-component references and dependencies\n   - Test performance under realistic data loads\n\n3. User Acceptance Testing:\n   - Create test scenarios for common user workflows\n   - Verify intuitive navigation between sections\n   - Test responsiveness on different devices and screen sizes\n   - Validate accessibility features\n   - Gather feedback on user experience and make necessary adjustments\n\n4. Regression Testing:\n   - Ensure changes don't break functionality in previous chapters\n   - Verify data integrity across the entire report structure\n   - Test backward compatibility with existing data\n   - Validate consistent behavior across all integrated components",
        "status": "pending",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Ch5 Light & Shadow: Data Field Definition, Template Markdown Prompt, API Storage/Cascade, and UI Section Binding",
        "description": "Define and implement the Ch5 Light & Shadow component by finalizing data fields, creating markdown prompt templates, establishing API storage with cascade functionality, and binding UI sections to the data structure.",
        "details": "This task involves implementing the Ch5 Light & Shadow component with the following steps:\n\n1. Data Field Definition:\n   - Define all required data fields for the Light & Shadow component\n   - Document field types, validation rules, and constraints\n   - Establish relationships between fields\n   - Create schema validation for input data\n   - Define default values and initialization logic\n   - Ensure compatibility with the overall report structure defined in Task #1\n\n2. Template Markdown Prompt:\n   - Create standardized markdown templates for the Light & Shadow prompts\n   - Implement variable substitution for dynamic content\n   - Design templates for different states (initial, partially completed, fully completed)\n   - Establish formatting rules for consistent presentation\n   - Create helper functions for template rendering\n   - Document template usage guidelines\n\n3. API Storage/Cascade:\n   - Implement API endpoints for storing Light & Shadow data\n   - Create data retrieval endpoints with appropriate filtering\n   - Establish cascade functionality to update dependent components\n   - Implement validation middleware for data integrity\n   - Set up error handling and response formatting\n   - Document API usage with examples\n   - Ensure proper integration with authentication system\n\n4. UI Section Binding:\n   - Create UI components for the Light & Shadow section\n   - Implement data binding between UI and API\n   - Set up form validation and error handling\n   - Create interactive elements for user input\n   - Implement state management for the component\n   - Ensure responsive design for different devices\n   - Add accessibility features for inclusive user experience\n   - Integrate with navigation and overall UI flow\n\n5. Integration with Previous Chapters:\n   - Ensure data consistency with previous chapter components\n   - Implement cross-referencing between related sections\n   - Create logical transitions between chapters\n   - Maintain consistent styling and user experience",
        "testStrategy": "1. Unit Testing:\n   - Test each data field with valid and invalid inputs\n   - Verify markdown template rendering with various data inputs\n   - Test API endpoints for storing and retrieving Light & Shadow data\n   - Validate cascade functionality with different update scenarios\n   - Test UI components in isolation with mock data\n   - Verify form validation logic with edge cases\n\n2. Integration Testing:\n   - Test the interaction between UI components and API endpoints\n   - Verify data flow between frontend and backend systems\n   - Test cascade updates across dependent components\n   - Validate cross-chapter references and data consistency\n   - Ensure proper state management across the application\n\n3. User Acceptance Testing:\n   - Verify the Light & Shadow component meets design specifications\n   - Test the user flow for completing the Light & Shadow section\n   - Validate the rendering of completed content in report view\n   - Test the component on different devices and screen sizes\n   - Verify accessibility compliance with WCAG standards\n\n4. Performance Testing:\n   - Measure API response times for data operations\n   - Test UI rendering performance with various data loads\n   - Verify memory usage during component interactions\n   - Test concurrent user scenarios\n\n5. Documentation Verification:\n   - Review API documentation for completeness\n   - Verify user guide sections for the Light & Shadow component\n   - Validate technical documentation for developers",
        "status": "pending",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Ch6 Philosophy: Data Field Definition, Template Markdown Prompt, API Storage/Cascade, and UI Section Binding",
        "description": "Define and implement the Ch6 Philosophy component by finalizing data fields, creating markdown prompt templates, establishing API storage with cascade functionality, and binding UI sections to the data structure.",
        "details": "This task involves implementing the Ch6 Philosophy component with the following steps:\n\n1. Data Field Definition:\n   - Define all required data fields for the Philosophy component\n   - Document field types, validation rules, and constraints\n   - Establish relationships between fields\n   - Create schema validation for input data\n   - Define default values and initialization logic\n   - Ensure compatibility with the overall report structure defined in Task #1\n\n2. Template Markdown Prompt:\n   - Create standardized markdown templates for the Philosophy prompts\n   - Implement variable substitution for dynamic content\n   - Design templates for different sections of the Philosophy component\n   - Ensure templates follow the established style guidelines\n   - Create helper functions for template rendering\n   - Document template usage and customization options\n\n3. API Storage/Cascade:\n   - Implement API endpoints for storing Philosophy component data\n   - Design database schema for Philosophy data storage\n   - Implement cascade functionality to propagate changes to dependent components\n   - Create data validation middleware for API endpoints\n   - Implement error handling and response formatting\n   - Document API usage with examples and parameter descriptions\n   - Ensure proper authentication and authorization for data access\n\n4. UI Section Binding:\n   - Create UI components for the Philosophy section\n   - Implement data binding between UI elements and the data model\n   - Design form controls for data input and editing\n   - Implement validation feedback for user inputs\n   - Create visualization components for Philosophy data representation\n   - Ensure responsive design for different screen sizes\n   - Implement accessibility features for UI components\n   - Document component usage and customization options",
        "testStrategy": "1. Unit Testing:\n   - Test each data field with valid and invalid inputs\n   - Verify markdown template rendering with various data inputs\n   - Test API endpoints for storing and retrieving Philosophy data\n   - Validate cascade functionality with different update scenarios\n   - Test UI components in isolation with mock data\n\n2. Integration Testing:\n   - Verify data flow between UI components and API endpoints\n   - Test cascade updates across dependent components\n   - Validate form submission and data persistence\n   - Test error handling and user feedback mechanisms\n   - Verify template rendering in the context of the full application\n\n3. User Acceptance Testing:\n   - Validate that the Philosophy component meets business requirements\n   - Test the component with real user scenarios\n   - Verify that the UI is intuitive and user-friendly\n   - Ensure all functionality is accessible and works as expected\n   - Validate that the component integrates properly with other report sections\n\n4. Performance Testing:\n   - Measure API response times under various load conditions\n   - Test UI rendering performance with large datasets\n   - Validate cascade update performance with complex dependency chains\n   - Ensure template rendering is efficient and responsive\n\n5. Cross-browser Testing:\n   - Verify functionality across major browsers (Chrome, Firefox, Safari, Edge)\n   - Test responsive design on different devices and screen sizes\n   - Ensure accessibility features work across all supported platforms",
        "status": "pending",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Ch7 Action Recipe: Data Field Definition, Template Markdown Prompt, API Storage/Cascade, and UI Section Binding",
        "description": "Define and implement the Ch7 Action Recipe component by finalizing data fields, creating markdown prompt templates, establishing API storage with cascade functionality, and binding UI sections to the data structure.",
        "details": "This task involves implementing the Ch7 Action Recipe component with the following steps:\n\n1. Data Field Definition:\n   - Define all required data fields for the Action Recipe component\n   - Document field types, validation rules, and constraints\n   - Establish relationships between fields\n   - Create schema validation for input data\n   - Define default values and initialization logic\n   - Ensure compatibility with the overall report structure defined in Task #1\n\n2. Template Markdown Prompt:\n   - Create markdown templates for generating Action Recipe content\n   - Define variable placeholders within templates\n   - Implement conditional rendering logic for different scenarios\n   - Design templates that maintain consistent formatting with other report sections\n   - Include guidance text for AI-assisted content generation\n   - Ensure templates support multilingual content\n\n3. API Storage/Cascade:\n   - Implement API endpoints for storing Action Recipe data\n   - Create data retrieval endpoints with appropriate filtering\n   - Establish cascade update functionality to propagate changes to dependent components\n   - Implement versioning for tracking changes to Action Recipe data\n   - Set up data validation middleware\n   - Create error handling for API operations\n   - Document API endpoints and usage examples\n\n4. UI Section Binding:\n   - Develop UI components for displaying and editing Action Recipe data\n   - Bind UI elements to the data structure\n   - Implement real-time validation and feedback\n   - Create interactive elements for modifying Action Recipe content\n   - Design responsive layouts for different device sizes\n   - Implement accessibility features\n   - Ensure consistent styling with the overall application theme\n\n5. Integration:\n   - Connect the Action Recipe component with related report sections\n   - Ensure data flow between interdependent components\n   - Implement event handlers for cross-component interactions\n   - Test integration points with dependent components\n   - Document integration requirements and dependencies",
        "testStrategy": "1. Unit Testing:\n   - Test each data field with valid and invalid inputs\n   - Verify markdown template rendering with various data inputs\n   - Test API endpoints for storing and retrieving Action Recipe data\n   - Validate cascade functionality with different update scenarios\n   - Test UI components in isolation with mock data\n\n2. Integration Testing:\n   - Verify data flow between Action Recipe and related components\n   - Test cascade updates across multiple components\n   - Validate that UI changes properly reflect in the data model\n   - Test API interactions in an integrated environment\n   - Verify template rendering in the context of the full report\n\n3. User Acceptance Testing:\n   - Validate that Action Recipe content meets business requirements\n   - Test the editing workflow from end-user perspective\n   - Verify that generated content follows expected patterns\n   - Test responsiveness and usability on different devices\n   - Validate accessibility compliance\n\n4. Performance Testing:\n   - Measure API response times under various load conditions\n   - Test UI rendering performance with complex Action Recipe data\n   - Validate cascade update performance with large datasets\n   - Benchmark template rendering times\n\n5. Regression Testing:\n   - Ensure changes don't break existing functionality\n   - Verify compatibility with previously created reports\n   - Test backward compatibility with older data formats",
        "status": "pending",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Ch8 Future Path: Data Field Definition, Template Markdown Prompt, API Storage/Cascade, and UI Section Binding",
        "description": "Define and implement the Ch8 Future Path component by finalizing data fields, creating markdown prompt templates, establishing API storage with cascade functionality, and binding UI sections to the data structure.",
        "details": "This task involves implementing the Ch8 Future Path component with the following steps:\n\n1. Data Field Definition:\n   - Define all required data fields for the Future Path component\n   - Document field types, validation rules, and constraints\n   - Establish relationships between fields\n   - Create schema validation for input data\n   - Define default values and initialization logic\n   - Ensure compatibility with the overall report structure defined in Task #1\n   - Include fields for future goals, development areas, and recommended next steps\n   - Define data structures for timeline projections and milestone tracking\n\n2. Template Markdown Prompt:\n   - Create markdown templates for the Future Path section\n   - Design prompts that guide users to articulate future development paths\n   - Implement variable substitution in templates\n   - Create conditional sections based on user inputs\n   - Design templates that adapt based on previous chapter inputs\n   - Include formatting guidelines for consistency\n   - Develop helper text and examples for each prompt section\n   - Ensure templates support multilingual content\n\n3. API Storage/Cascade:\n   - Implement API endpoints for storing Future Path data\n   - Create data validation middleware\n   - Establish cascade functionality to update dependent sections\n   - Implement version control for Future Path data\n   - Create data retrieval endpoints with filtering options\n   - Design batch update capabilities\n   - Implement data migration strategies for schema changes\n   - Ensure proper error handling and logging\n   - Add security measures for data protection\n\n4. UI Section Binding:\n   - Develop UI components for the Future Path section\n   - Bind UI elements to the data structure\n   - Implement real-time validation and feedback\n   - Create interactive timeline visualization components\n   - Design responsive layouts for different devices\n   - Implement state management for complex form interactions\n   - Add progress indicators and save functionality\n   - Ensure accessibility compliance\n   - Create print-friendly views of the Future Path section\n\n5. Integration with Previous Chapters:\n   - Establish data relationships with previous chapter components\n   - Implement data inheritance where appropriate\n   - Create summary views that incorporate insights from earlier chapters\n   - Design navigation between related sections\n   - Ensure consistent styling and interaction patterns",
        "testStrategy": "1. Unit Testing:\n   - Test each data field with valid and invalid inputs\n   - Verify markdown template rendering with various data inputs\n   - Test API endpoints for storing and retrieving Future Path data\n   - Validate cascade functionality with different update scenarios\n   - Test UI components in isolation with mock data\n   - Verify form validation logic\n   - Test conditional rendering based on different input combinations\n\n2. Integration Testing:\n   - Verify data flow between UI components and API endpoints\n   - Test cascade updates across related components\n   - Validate that changes in previous chapters correctly influence Future Path content\n   - Test navigation between connected sections\n   - Verify data persistence across page refreshes\n   - Test import/export functionality with the Future Path data\n\n3. User Acceptance Testing:\n   - Conduct usability testing with representative users\n   - Verify that the Future Path section meets business requirements\n   - Test the complete workflow from data entry to final report generation\n   - Validate that the Future Path content properly reflects insights from previous chapters\n   - Verify that the UI is intuitive and responsive\n\n4. Performance Testing:\n   - Measure load times for the Future Path section with various data sizes\n   - Test API response times under different load conditions\n   - Verify client-side performance with profiling tools\n   - Test memory usage with large datasets\n\n5. Cross-browser and Device Testing:\n   - Verify functionality across major browsers\n   - Test responsive design on various device sizes\n   - Validate touch interactions on mobile devices\n   - Test print functionality for the Future Path section",
        "status": "pending",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Ch9 Epilogue: Data Field Definition, Template Markdown Prompt, API Storage/Cascade, and UI Section Binding",
        "description": "Define and implement the Ch9 Epilogue component by finalizing data fields, creating markdown prompt templates, establishing API storage with cascade functionality, and binding UI sections to the data structure.",
        "details": "This task involves implementing the Ch9 Epilogue component with the following steps:\n\n1. Data Field Definition:\n   - Define all required data fields for the Epilogue component\n   - Document field types, validation rules, and constraints\n   - Establish relationships between fields\n   - Create schema validation for input data\n   - Define default values and initialization logic\n   - Ensure compatibility with the overall report structure defined in Task #1\n   - Include fields for conclusion summaries, final reflections, and future recommendations\n\n2. Template Markdown Prompt:\n   - Create markdown templates for the Epilogue section\n   - Design prompts that guide users to provide meaningful closing reflections\n   - Implement variable substitution in templates\n   - Create helper functions for formatting complex data\n   - Ensure templates maintain consistent styling with other report sections\n   - Include conditional rendering logic for optional epilogue elements\n   - Design templates to reference key insights from previous chapters\n\n3. API Storage/Cascade:\n   - Implement API endpoints for storing and retrieving Epilogue data\n   - Establish data validation before storage\n   - Create cascade functionality to update dependent data when Epilogue content changes\n   - Implement versioning for Epilogue data\n   - Set up proper error handling and response formatting\n   - Create documentation for API endpoints\n   - Implement caching strategies for frequently accessed data\n\n4. UI Section Binding:\n   - Develop UI components for the Epilogue section\n   - Bind UI elements to the data structure\n   - Implement form validation for user inputs\n   - Create interactive elements for editing Epilogue content\n   - Ensure responsive design for various screen sizes\n   - Implement real-time preview of markdown rendering\n   - Add navigation elements to connect with previous chapters\n   - Design visual indicators for incomplete or invalid sections\n\n5. Integration:\n   - Connect the Epilogue component with the overall report structure\n   - Ensure proper data flow between chapters\n   - Implement navigation between the Epilogue and previous chapters\n   - Test the complete report generation with the Epilogue included\n   - Verify that all cross-references between chapters work correctly",
        "testStrategy": "1. Unit Testing:\n   - Test each data field with valid and invalid inputs\n   - Verify markdown template rendering with various data inputs\n   - Test API endpoints for storing and retrieving Epilogue data\n   - Validate cascade functionality with different update scenarios\n   - Test UI components in isolation with mock data\n   - Verify form validation logic for all input fields\n   - Test conditional rendering logic in templates\n\n2. Integration Testing:\n   - Verify proper integration with previous chapter components\n   - Test data flow between connected components\n   - Validate that changes in previous chapters correctly reflect in the Epilogue\n   - Test navigation between the Epilogue and other report sections\n   - Verify that the complete report generates correctly with the Epilogue included\n\n3. User Acceptance Testing:\n   - Conduct usability testing with representative users\n   - Verify that the Epilogue UI is intuitive and easy to use\n   - Test the complete report workflow from start to finish\n   - Gather feedback on the Epilogue template prompts and adjust as needed\n   - Verify that the Epilogue effectively summarizes the report content\n\n4. Performance Testing:\n   - Measure load times for the Epilogue section with various data sizes\n   - Test API response times under different load conditions\n   - Verify that cascade updates complete within acceptable time limits\n   - Test markdown rendering performance with complex content\n\n5. Regression Testing:\n   - Ensure that implementing the Epilogue doesn't break existing functionality\n   - Verify that all previous chapter components still work correctly\n   - Test the complete report generation process end-to-end",
        "status": "pending",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-04T06:54:32.984Z",
      "updated": "2025-09-04T07:19:58.678Z",
      "description": "차세대 보고서(전 섹션) 재설계/재구현 태그"
    }
  }
}